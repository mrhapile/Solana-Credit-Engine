import { PublicKey, Transaction, SystemProgram, SYSVAR_RENT_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';
import BN from 'bn.js';
import { Program, AnchorProvider } from '@coral-xyz/anchor';
import { l as liquidity } from './lend.CioR9-te.mjs';
import { getAssociatedTokenAddressSync, ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { a as getTickHasDebt, v as vaultsIdl, c as getPosition, d as getTick, e as getTickIdLiquidation, f as getVaultConfig, h as getBranch, i as getVaultState, j as getVaultMetadata, k as getLiquidity, l as getRateModel, m as getUserBorrowPosition, n as getUserSupplyPosition, o as getLiquidityReserve, p as getPositionTokenAccount, q as getPositionMetadata, r as getPositionMint, g as getVaultAdmin, s as getClaimAccount } from './lend.C2-jCLFw.mjs';
import { e as getReserve } from './lend.BzG5ldOV.mjs';

const address = "jupnw4B6Eqs7ft6rxpzYLJZYSnrpRgPcr589n5Kv4oc";
const metadata = {
	name: "oracle",
	version: "0.1.0",
	spec: "0.1.0",
	description: "Created with Anchor"
};
const instructions = [
	{
		name: "get_both_exchange_rate",
		discriminator: [
			92,
			88,
			161,
			46,
			230,
			193,
			46,
			237
		],
		accounts: [
			{
				name: "oracle"
			}
		],
		args: [
			{
				name: "_nonce",
				type: "u16"
			}
		]
	},
	{
		name: "get_exchange_rate",
		discriminator: [
			153,
			76,
			17,
			194,
			170,
			215,
			89,
			142
		],
		accounts: [
			{
				name: "oracle"
			}
		],
		args: [
			{
				name: "_nonce",
				type: "u16"
			}
		],
		returns: "u128"
	},
	{
		name: "get_exchange_rate_liquidate",
		discriminator: [
			228,
			169,
			73,
			39,
			91,
			82,
			27,
			5
		],
		accounts: [
			{
				name: "oracle"
			}
		],
		args: [
			{
				name: "_nonce",
				type: "u16"
			}
		],
		returns: "u128"
	},
	{
		name: "get_exchange_rate_operate",
		discriminator: [
			174,
			166,
			126,
			10,
			122,
			153,
			94,
			203
		],
		accounts: [
			{
				name: "oracle"
			}
		],
		args: [
			{
				name: "_nonce",
				type: "u16"
			}
		],
		returns: "u128"
	},
	{
		name: "init_admin",
		discriminator: [
			97,
			65,
			97,
			27,
			200,
			206,
			72,
			219
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "oracle_admin",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								111,
								114,
								97,
								99,
								108,
								101,
								95,
								97,
								100,
								109,
								105,
								110
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "authority",
				type: "pubkey"
			}
		]
	},
	{
		name: "init_oracle_config",
		discriminator: [
			77,
			144,
			180,
			246,
			217,
			15,
			118,
			92
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "oracle_admin"
			},
			{
				name: "oracle",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								111,
								114,
								97,
								99,
								108,
								101
							]
						},
						{
							kind: "arg",
							path: "nonce"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "sources",
				type: {
					vec: {
						defined: {
							name: "Sources"
						}
					}
				}
			},
			{
				name: "nonce",
				type: "u16"
			}
		]
	},
	{
		name: "update_authority",
		discriminator: [
			32,
			46,
			64,
			28,
			149,
			75,
			243,
			88
		],
		accounts: [
			{
				name: "authority",
				signer: true
			},
			{
				name: "oracle_admin",
				writable: true
			}
		],
		args: [
			{
				name: "new_authority",
				type: "pubkey"
			}
		]
	},
	{
		name: "update_auths",
		discriminator: [
			93,
			96,
			178,
			156,
			57,
			117,
			253,
			209
		],
		accounts: [
			{
				name: "authority",
				signer: true
			},
			{
				name: "oracle_admin",
				writable: true
			}
		],
		args: [
			{
				name: "auth_status",
				type: {
					vec: {
						defined: {
							name: "AddressBool"
						}
					}
				}
			}
		]
	}
];
const accounts = [
	{
		name: "Oracle",
		discriminator: [
			139,
			194,
			131,
			179,
			140,
			179,
			229,
			244
		]
	},
	{
		name: "OracleAdmin",
		discriminator: [
			239,
			232,
			8,
			20,
			254,
			63,
			25,
			246
		]
	}
];
const events = [
	{
		name: "LogStakePoolHighFeeDetected",
		discriminator: [
			198,
			106,
			149,
			7,
			25,
			83,
			39,
			155
		]
	},
	{
		name: "LogUpdateAuthority",
		discriminator: [
			150,
			152,
			157,
			143,
			6,
			135,
			193,
			101
		]
	},
	{
		name: "LogUpdateAuths",
		discriminator: [
			88,
			80,
			109,
			48,
			111,
			203,
			76,
			251
		]
	}
];
const errors = [
	{
		code: 6000,
		name: "PriceNotValid",
		msg: "PRICE_NOT_VALID"
	},
	{
		code: 6001,
		name: "PriceTooOld",
		msg: "PRICE_TOO_OLD"
	},
	{
		code: 6002,
		name: "RateZero",
		msg: "RATE_ZERO"
	},
	{
		code: 6003,
		name: "InvalidParams",
		msg: "INVALID_PARAMS"
	},
	{
		code: 6004,
		name: "InvalidPythSourceMultiplierAndDivisor",
		msg: "INVALID_PYTH_SOURCE_MULTIPLIER_AND_DIVISOR"
	},
	{
		code: 6005,
		name: "InvalidSource",
		msg: "INVALID_SOURCE"
	},
	{
		code: 6006,
		name: "InvalidSourcesLength",
		msg: "INVALID_SOURCES_LENGTH"
	},
	{
		code: 6007,
		name: "OracleAdminOnlyAuthority",
		msg: "ORACLE_ADMIN_ONLY_AUTHORITY"
	},
	{
		code: 6008,
		name: "OracleAdminOnlyAuth",
		msg: "ORACLE_ADMIN_ONLY_AUTH"
	},
	{
		code: 6009,
		name: "OracleAdminMaxAuthCountReached",
		msg: "ORACLE_ADMIN_MAX_AUTH_COUNT_REACHED"
	},
	{
		code: 6010,
		name: "OracleAdminInvalidParams",
		msg: "ORACLE_ADMIN_INVALID_PARAMS"
	},
	{
		code: 6011,
		name: "OracleNonceMismatch",
		msg: "ORACLE_NONCE_MISMATCH"
	},
	{
		code: 6012,
		name: "PriceConfidenceNotSufficient",
		msg: "PRICE_CONFIDENCE_NOT_SUFFICIENT"
	},
	{
		code: 6013,
		name: "StakePoolNotRefreshed",
		msg: "STAKE_POOL_NOT_REFRESHED"
	},
	{
		code: 6014,
		name: "InvalidPrice",
		msg: "INVALID_PRICE"
	},
	{
		code: 6015,
		name: "FeeTooHigh",
		msg: "FEE_TOO_HIGH"
	},
	{
		code: 6016,
		name: "RedstonePriceOverflow",
		msg: "REDSTONE_PRICE_OVERFLOW"
	},
	{
		code: 6017,
		name: "TimestampExpected",
		msg: "TIMESTAMP_EXPECTED"
	},
	{
		code: 6018,
		name: "CpiToStakeProgramFailed",
		msg: "CPI_TO_STAKE_PROGRAM_FAILED"
	},
	{
		code: 6019,
		name: "InvalidStakePoolReturnParams",
		msg: "INVALID_STAKE_POOL_RETURN_PARAMS"
	},
	{
		code: 6020,
		name: "ChainlinkPriceReadError",
		msg: "CHAINLINK_PRICE_READ_ERROR"
	},
	{
		code: 6021,
		name: "SinglePoolTokenSupplyZero",
		msg: "SINGLE_POOL_TOKEN_SUPPLY_ZERO"
	},
	{
		code: 6022,
		name: "SinglePoolInvalidStakeAccount",
		msg: "SINGLE_POOL_INVALID_STAKE_ACCOUNT"
	},
	{
		code: 6023,
		name: "SinglePoolInvalidMint",
		msg: "SINGLE_POOL_INVALID_MINT"
	}
];
const types = [
	{
		name: "AddressBool",
		type: {
			kind: "struct",
			fields: [
				{
					name: "addr",
					type: "pubkey"
				},
				{
					name: "value",
					type: "bool"
				}
			]
		}
	},
	{
		name: "LogStakePoolHighFeeDetected",
		type: {
			kind: "struct",
			fields: [
				{
					name: "stake_pool",
					type: "pubkey"
				},
				{
					name: "epoch",
					type: "u64"
				}
			]
		}
	},
	{
		name: "LogUpdateAuthority",
		type: {
			kind: "struct",
			fields: [
				{
					name: "new_authority",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "LogUpdateAuths",
		type: {
			kind: "struct",
			fields: [
				{
					name: "auth_status",
					type: {
						vec: {
							defined: {
								name: "AddressBool"
							}
						}
					}
				}
			]
		}
	},
	{
		name: "Oracle",
		type: {
			kind: "struct",
			fields: [
				{
					name: "nonce",
					type: "u16"
				},
				{
					name: "sources",
					type: {
						vec: {
							defined: {
								name: "Sources"
							}
						}
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "OracleAdmin",
		type: {
			kind: "struct",
			fields: [
				{
					name: "authority",
					type: "pubkey"
				},
				{
					name: "auths",
					type: {
						vec: "pubkey"
					}
				}
			]
		}
	},
	{
		name: "SourceType",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Pyth"
				},
				{
					name: "StakePool"
				},
				{
					name: "MsolPool"
				},
				{
					name: "Redstone"
				},
				{
					name: "Chainlink"
				},
				{
					name: "SinglePool"
				}
			]
		}
	},
	{
		name: "Sources",
		type: {
			kind: "struct",
			fields: [
				{
					name: "source",
					type: "pubkey"
				},
				{
					name: "invert",
					type: "bool"
				},
				{
					name: "multiplier",
					type: "u128"
				},
				{
					name: "divisor",
					type: "u128"
				},
				{
					name: "source_type",
					type: {
						defined: {
							name: "SourceType"
						}
					}
				}
			]
		}
	}
];
const oracle = {
	address: address,
	metadata: metadata,
	instructions: instructions,
	accounts: accounts,
	events: events,
	errors: errors,
	types: types
};

const MIN_TICK$1 = -16383;
const MAX_TICK$1 = 16383;
const ZERO_TICK_SCALED_RATIO$1 = new BN(281474976710656);
const TICK_HAS_DEBT_ARRAY_SIZE = 8;
const TICKS_PER_TICK_HAS_DEBT = TICK_HAS_DEBT_ARRAY_SIZE * 256;
const TICK_HAS_DEBT_CHILDREN_SIZE = 32;
const TICK_HAS_DEBT_CHILDREN_SIZE_IN_BITS = 256;
const TOTAL_INDICES_NEEDED = 16;
function getRatioAtTick(tick) {
  if (tick < MIN_TICK$1 || tick > MAX_TICK$1) {
    throw new Error(`Tick ${tick} out of range [${MIN_TICK$1}, ${MAX_TICK$1}]`);
  }
  const FACTOR00 = new BN("18446744073709551616");
  const FACTOR01 = new BN("18419115400608638658");
  const FACTOR02 = new BN("18391528108445969703");
  const FACTOR03 = new BN("18336477419114433396");
  const FACTOR04 = new BN("18226869890870665593");
  const FACTOR05 = new BN("18009616477100071088");
  const FACTOR06 = new BN("17582847377087825313");
  const FACTOR07 = new BN("16759408633341240198");
  const FACTOR08 = new BN("15226414841393184936");
  const FACTOR09 = new BN("12568272644527235157");
  const FACTOR10 = new BN("8563108841104354677");
  const FACTOR11 = new BN("3975055583337633975");
  const FACTOR12 = new BN("856577552520149366");
  const FACTOR13 = new BN("39775317560084773");
  const FACTOR14 = new BN("85764505686420");
  const FACTOR15 = new BN("398745188");
  const absTick = Math.abs(tick);
  let factor = FACTOR00;
  if (absTick & 1) factor = FACTOR01;
  if (absTick & 2) factor = mulShift64(factor, FACTOR02);
  if (absTick & 4) factor = mulShift64(factor, FACTOR03);
  if (absTick & 8) factor = mulShift64(factor, FACTOR04);
  if (absTick & 16) factor = mulShift64(factor, FACTOR05);
  if (absTick & 32) factor = mulShift64(factor, FACTOR06);
  if (absTick & 64) factor = mulShift64(factor, FACTOR07);
  if (absTick & 128) factor = mulShift64(factor, FACTOR08);
  if (absTick & 256) factor = mulShift64(factor, FACTOR09);
  if (absTick & 512) factor = mulShift64(factor, FACTOR10);
  if (absTick & 1024) factor = mulShift64(factor, FACTOR11);
  if (absTick & 2048) factor = mulShift64(factor, FACTOR12);
  if (absTick & 4096) factor = mulShift64(factor, FACTOR13);
  if (absTick & 8192) factor = mulShift64(factor, FACTOR14);
  if (absTick & 16384) factor = mulShift64(factor, FACTOR15);
  let precision = new BN(0);
  if (tick > 0) {
    const maxU128 = new BN(2).pow(new BN(128)).sub(new BN(1));
    factor = maxU128.div(factor);
    if (!factor.mod(new BN(65536)).isZero()) {
      precision = new BN(1);
    }
  }
  const ratioX48 = factor.shrn(16).add(precision);
  return ratioX48;
}
function mulShift64(n0, n1) {
  try {
    return n0.mul(n1).shrn(64);
  } catch {
    const product = n0.mul(n1);
    return product.div(new BN(2).pow(new BN(64)));
  }
}
function getTickAtRatio(ratioX48) {
  const MIN_RATIOX48 = new BN(6093);
  const MAX_RATIOX48 = new BN("13002088133096036565414295");
  const _1E13 = new BN("10000000000000");
  if (ratioX48.lt(MIN_RATIOX48) || ratioX48.gt(MAX_RATIOX48)) {
    throw new Error(`Ratio ${ratioX48.toString()} out of bounds`);
  }
  const isNegative = ratioX48.lt(ZERO_TICK_SCALED_RATIO$1);
  let factor;
  factor = isNegative ? ZERO_TICK_SCALED_RATIO$1.mul(_1E13).div(ratioX48) : ratioX48.mul(_1E13).div(ZERO_TICK_SCALED_RATIO$1);
  let tick = 0;
  if (factor.gte(new BN("2150859953785115391"))) {
    tick |= 8192;
    factor = factor.mul(_1E13).div(new BN("2150859953785115391"));
  }
  if (factor.gte(new BN("4637736467054931"))) {
    tick |= 4096;
    factor = factor.mul(_1E13).div(new BN("4637736467054931"));
  }
  if (factor.gte(new BN("215354044936586"))) {
    tick |= 2048;
    factor = factor.mul(_1E13).div(new BN("215354044936586"));
  }
  if (factor.gte(new BN("46406254420777"))) {
    tick |= 1024;
    factor = factor.mul(_1E13).div(new BN("46406254420777"));
  }
  if (factor.gte(new BN("21542110950596"))) {
    tick |= 512;
    factor = factor.mul(_1E13).div(new BN("21542110950596"));
  }
  if (factor.gte(new BN("14677230989051"))) {
    tick |= 256;
    factor = factor.mul(_1E13).div(new BN("14677230989051"));
  }
  if (factor.gte(new BN("12114962232319"))) {
    tick |= 128;
    factor = factor.mul(_1E13).div(new BN("12114962232319"));
  }
  if (factor.gte(new BN("11006798913544"))) {
    tick |= 64;
    factor = factor.mul(_1E13).div(new BN("11006798913544"));
  }
  if (factor.gte(new BN("10491329235871"))) {
    tick |= 32;
    factor = factor.mul(_1E13).div(new BN("10491329235871"));
  }
  if (factor.gte(new BN("10242718992470"))) {
    tick |= 16;
    factor = factor.mul(_1E13).div(new BN("10242718992470"));
  }
  if (factor.gte(new BN("10120631893548"))) {
    tick |= 8;
    factor = factor.mul(_1E13).div(new BN("10120631893548"));
  }
  if (factor.gte(new BN("10060135135051"))) {
    tick |= 4;
    factor = factor.mul(_1E13).div(new BN("10060135135051"));
  }
  if (factor.gte(new BN("10030022500000"))) {
    tick |= 2;
    factor = factor.mul(_1E13).div(new BN("10030022500000"));
  }
  if (factor.gte(new BN("10015000000000"))) {
    tick |= 1;
  }
  if (isNegative) {
    tick = ~tick;
  }
  return tick;
}
function getFirstTickForIndex(index) {
  if (index >= TOTAL_INDICES_NEEDED) {
    throw new Error(
      `Invalid index: ${index}. Must be between 0 and ${TOTAL_INDICES_NEEDED - 1}`
    );
  }
  return MIN_TICK$1 + index * TICKS_PER_TICK_HAS_DEBT;
}
function getTickIndices(tick) {
  if (tick < MIN_TICK$1 || tick > MAX_TICK$1) {
    throw new Error("Tick out of range");
  }
  const tickOffset = tick - MIN_TICK$1;
  const arrayIndex = Math.floor(tickOffset / TICKS_PER_TICK_HAS_DEBT);
  const firstTickForIndex = getFirstTickForIndex(arrayIndex);
  const tickWithinArray = tick - firstTickForIndex;
  const mapIndex = Math.floor(
    tickWithinArray / TICK_HAS_DEBT_CHILDREN_SIZE_IN_BITS
  );
  const tickWithinMap = tickWithinArray % TICK_HAS_DEBT_CHILDREN_SIZE_IN_BITS;
  const byteIndex = Math.floor(tickWithinMap / 8);
  const bitIndex = tickWithinMap % 8;
  return { arrayIndex, mapIndex, byteIndex, bitIndex };
}
async function readTickHasDebtArray({
  vaultId,
  index,
  program
}) {
  const tickPda = getTickHasDebt(vaultId, index);
  return await program.account.tickHasDebtArray.fetch(tickPda);
}
async function findNextTickWithDebt(vaultId, startTick, program) {
  try {
    const { arrayIndex, mapIndex, byteIndex, bitIndex } = getTickIndices(startTick);
    let currentArrayIndex = arrayIndex;
    let currentMapIndex = mapIndex;
    let tickHasDebtData = await readTickHasDebtArray({
      vaultId,
      index: currentArrayIndex,
      program
    });
    if (!tickHasDebtData) {
      return MIN_TICK$1;
    }
    clearBitsInBitmap(tickHasDebtData, mapIndex, byteIndex, bitIndex);
    while (true) {
      const { nextTick, hasNextTick } = fetchNextTopTickFromBitmap(
        tickHasDebtData,
        currentMapIndex
      );
      if (hasNextTick && nextTick !== MIN_TICK$1) {
        return nextTick;
      }
      if (currentArrayIndex === 0) {
        return MIN_TICK$1;
      }
      currentArrayIndex -= 1;
      currentMapIndex = TICK_HAS_DEBT_ARRAY_SIZE - 1;
      tickHasDebtData = await readTickHasDebtArray({
        vaultId,
        index: currentArrayIndex,
        program
      });
      if (!tickHasDebtData) {
        return MIN_TICK$1;
      }
    }
  } catch (error) {
    console.warn(`Error finding next tick with debt:`, error);
    return MIN_TICK$1;
  }
}
function clearBitsInBitmap(tickHasDebtData, mapIndex, byteIndex, bitIndex) {
  const bitmap = [...tickHasDebtData.tickHasDebt[mapIndex].childrenBits];
  if (bitIndex > 0) {
    const mask = (1 << bitIndex) - 1;
    bitmap[byteIndex] &= mask;
  } else {
    bitmap[byteIndex] = 0;
  }
  for (let i = byteIndex + 1; i < TICK_HAS_DEBT_CHILDREN_SIZE; i++) {
    bitmap[i] = 0;
  }
  tickHasDebtData.tickHasDebt[mapIndex].childrenBits = bitmap;
}
function fetchNextTopTickFromBitmap(tickHasDebtData, startMapIndex) {
  let mapIndex = startMapIndex;
  while (mapIndex >= 0) {
    if (hasBitsInMap(tickHasDebtData, mapIndex)) {
      const { nextTick, hasNextTick } = getNextTickFromMap(
        tickHasDebtData,
        mapIndex
      );
      if (hasNextTick) {
        return { nextTick, hasNextTick: true };
      }
    }
    mapIndex--;
  }
  return { nextTick: MIN_TICK$1, hasNextTick: false };
}
function hasBitsInMap(tickHasDebtData, mapIndex) {
  const childrenBits = tickHasDebtData.tickHasDebt[mapIndex].childrenBits;
  return childrenBits.some((byte) => byte !== 0);
}
function getNextTickFromMap(tickHasDebtData, mapIndex) {
  const childrenBits = tickHasDebtData.tickHasDebt[mapIndex].childrenBits;
  for (let byteIdx = TICK_HAS_DEBT_CHILDREN_SIZE - 1; byteIdx >= 0; byteIdx--) {
    if (childrenBits[byteIdx] !== 0) {
      const leadingZeros = getMostSignificantBit(childrenBits[byteIdx]);
      const bitPos = 7 - leadingZeros;
      const tickWithinMap = byteIdx * 8 + bitPos;
      const mapFirstTick = getFirstTickForMapIndex(
        tickHasDebtData.index,
        mapIndex
      );
      return {
        nextTick: mapFirstTick + tickWithinMap,
        hasNextTick: true
      };
    }
  }
  return { nextTick: MIN_TICK$1, hasNextTick: false };
}
function getMostSignificantBit(byte) {
  if (byte === 0) return 8;
  let leadingZeros = 0;
  let mask = 128;
  while ((byte & mask) === 0 && leadingZeros < 8) {
    leadingZeros++;
    mask >>>= 1;
  }
  return leadingZeros;
}
function getFirstTickForMapIndex(arrayIndex, mapIndex) {
  const arrayFirstTick = getFirstTickForIndex(arrayIndex);
  return arrayFirstTick + mapIndex * TICK_HAS_DEBT_CHILDREN_SIZE_IN_BITS;
}

const COEFFICIENT_SIZE_DEBT_FACTOR = 35;
const EXPONENT_SIZE_DEBT_FACTOR = 15;
const EXPONENT_MAX_DEBT_FACTOR = new BN(1).shln(EXPONENT_SIZE_DEBT_FACTOR).subn(1);
const DECIMALS_DEBT_FACTOR = new BN(16384);
const MAX_MASK_DEBT_FACTOR$1 = new BN(1).shln(COEFFICIENT_SIZE_DEBT_FACTOR + EXPONENT_SIZE_DEBT_FACTOR).subn(1);
const PRECISION = 64;
const TWO_POWER_64 = new BN("18446744073709551615");
const TWO_POWER_69_MINUS_1 = new BN(1).shln(69).subn(1);
const COEFFICIENT_PLUS_PRECISION = COEFFICIENT_SIZE_DEBT_FACTOR + PRECISION;
const COEFFICIENT_PLUS_PRECISION_MINUS_1 = COEFFICIENT_PLUS_PRECISION - 1;
new BN(1).shln(COEFFICIENT_PLUS_PRECISION_MINUS_1).subn(1);
new BN(1).shln(COEFFICIENT_PLUS_PRECISION_MINUS_1 - 1).subn(1);
function mulDivNormal(normal, bigNumber1, bigNumber2) {
  if (bigNumber1.isZero() || bigNumber2.isZero()) {
    return new BN(0);
  }
  const exponent1 = bigNumber1.and(EXPONENT_MAX_DEBT_FACTOR);
  const exponent2 = bigNumber2.and(EXPONENT_MAX_DEBT_FACTOR);
  if (exponent2.lt(exponent1)) {
    throw new Error("LibraryBnError: exponent2 should be >= exponent1");
  }
  const netExponent = exponent2.sub(exponent1);
  if (netExponent.lt(new BN(129))) {
    const coefficient1 = bigNumber1.shrn(EXPONENT_SIZE_DEBT_FACTOR);
    const coefficient2 = bigNumber2.shrn(EXPONENT_SIZE_DEBT_FACTOR);
    const numerator = normal.mul(coefficient1);
    const denominator = coefficient2.shln(netExponent.toNumber());
    if (denominator.isZero()) {
      throw new Error("LibraryDivisionByZero");
    }
    const result = numerator.div(denominator);
    if (result.gt(TWO_POWER_64)) {
      throw new Error("LibraryBnError: result overflow");
    }
    return result;
  } else {
    return new BN(0);
  }
}
function mulBigNumber(bigNumber1, bigNumber2) {
  const coefficient1 = bigNumber1.shrn(EXPONENT_SIZE_DEBT_FACTOR);
  const coefficient2 = bigNumber2.shrn(EXPONENT_SIZE_DEBT_FACTOR);
  const exponent1 = bigNumber1.and(EXPONENT_MAX_DEBT_FACTOR);
  const exponent2 = bigNumber2.and(EXPONENT_MAX_DEBT_FACTOR);
  const resCoefficient = coefficient1.mul(coefficient2);
  const overflowLen = resCoefficient.gt(TWO_POWER_69_MINUS_1) ? COEFFICIENT_SIZE_DEBT_FACTOR : COEFFICIENT_SIZE_DEBT_FACTOR - 1;
  const adjustedCoefficient = resCoefficient.shrn(overflowLen);
  const resExponent = exponent1.add(exponent2).add(new BN(overflowLen));
  if (resExponent.lt(DECIMALS_DEBT_FACTOR)) {
    throw new Error("LibraryBnError: exponent underflow");
  }
  const finalExponent = resExponent.sub(DECIMALS_DEBT_FACTOR);
  if (finalExponent.gt(EXPONENT_MAX_DEBT_FACTOR)) {
    return MAX_MASK_DEBT_FACTOR$1;
  }
  return adjustedCoefficient.shln(EXPONENT_SIZE_DEBT_FACTOR).or(finalExponent);
}

const getVaultsProgram = ({
  connection,
  signer
}) => new Program(vaultsIdl, {
  connection,
  publicKey: signer
});
const INIT_TICK = -2147483648;
const MIN_TICK = -16383;
const MAX_TICK = 16383;
const MAX_MASK_DEBT_FACTOR = new BN("1125899906842623");
const EXCHANGE_PRICES_PRECISION = new BN(10).pow(new BN(12));
const ZERO_TICK_SCALED_RATIO = new BN(281474976710656);
const TICK_SPACING = new BN(10015);
const X30 = new BN(1073741823);
const MIN_I128$1 = new BN("170141183460469231731687303715884105728").neg();
const getAccountOwner = async (account, connection) => {
  const info = await connection.getAccountInfo(account);
  if (!info)
    throw new Error(`Account info not found for ${account.toString()}`);
  return info.owner;
};
const getCurrentPosition = async ({
  vaultId,
  positionId,
  connection
}) => {
  const program = new Program(vaultsIdl, { connection });
  const position = await program.account.position.fetch(
    getPosition(vaultId, positionId)
  );
  return await getCurrentPositionState({
    vaultId,
    position,
    program
  });
};
const getCurrentPositionState = async ({
  vaultId,
  position,
  program
}) => {
  let positionTick = position.tick;
  if (positionTick === INIT_TICK) {
    positionTick = MIN_TICK;
  }
  if (position.isSupplyOnlyPosition) {
    return {
      tick: MIN_TICK,
      tickId: 0,
      colRaw: new BN(position.supplyAmount.toString()),
      finalAmount: new BN(position.supplyAmount.toString()),
      debtRaw: new BN(0),
      dustDebtRaw: new BN(0),
      isSupplyOnlyPosition: true,
      userLiquidationStatus: false,
      postLiquidationBranchId: 0
    };
  }
  const colRaw = new BN(position.supplyAmount.toString());
  const dustDebtRaw = new BN(position.dustDebtAmount.toString());
  let debtRaw = new BN(0);
  if (positionTick > MIN_TICK) {
    const collateralForDebtCalc = colRaw.add(new BN(1));
    const ratio = getRatioAtTick(positionTick);
    debtRaw = ratio.mul(collateralForDebtCalc).shrn(48).add(new BN(1));
  } else {
    debtRaw = new BN(0);
  }
  let userLiquidationStatus = false;
  let postLiquidationBranchId = 0;
  if (positionTick > MIN_TICK) {
    const tickData = await program.account.tick.fetch(
      getTick(vaultId, positionTick)
    );
    if (tickData.isLiquidated || tickData.totalIds > position.tickId) {
      userLiquidationStatus = true;
      let [tickIdData, branches] = await Promise.all([
        program.account.tickIdLiquidation.fetch(
          getTickIdLiquidation(
            vaultId,
            positionTick,
            position.tickId
          )
        ).catch(() => null),
        getAllBranches({ vaultId, program })
      ]);
      if (!tickIdData) {
        tickIdData = {
          vaultId,
          tick: positionTick,
          tickMap: position.tickId,
          isFullyLiquidated1: 0,
          liquidationBranchId1: 0,
          debtFactor1: new BN(0),
          isFullyLiquidated2: 0,
          liquidationBranchId2: 0,
          debtFactor2: new BN(0),
          isFullyLiquidated3: 0,
          liquidationBranchId3: 0,
          debtFactor3: new BN(0)
        };
      }
      const { isFullyLiquidated, branchId, connectionFactor } = getLiquidationStatus(position.tickId, tickData, tickIdData);
      postLiquidationBranchId = branchId;
      if (isFullyLiquidated) {
        return {
          tick: MIN_TICK,
          tickId: 0,
          colRaw: new BN(0),
          debtRaw: new BN(0),
          dustDebtRaw: new BN(0),
          finalAmount: new BN(0),
          isSupplyOnlyPosition: true,
          userLiquidationStatus: true,
          postLiquidationBranchId: 0
        };
      }
      const { finalTick, finalColRaw, finalDebtRaw } = processLiquidatedPosition({
        branches,
        branchId: postLiquidationBranchId,
        initialConnectionFactor: connectionFactor,
        initialDebtRaw: debtRaw
      });
      const netDebtRaw2 = finalDebtRaw.gt(dustDebtRaw) ? finalDebtRaw.sub(dustDebtRaw) : new BN(0);
      return {
        tick: finalTick,
        tickId: position.tickId,
        colRaw: finalColRaw,
        debtRaw: finalDebtRaw,
        dustDebtRaw,
        finalAmount: netDebtRaw2.gt(new BN(0)) ? finalColRaw : new BN(0),
        isSupplyOnlyPosition: finalTick === MIN_TICK,
        userLiquidationStatus,
        postLiquidationBranchId
      };
    }
  }
  const netDebtRaw = debtRaw.gt(dustDebtRaw) ? debtRaw.sub(dustDebtRaw) : new BN(0);
  return {
    tick: positionTick,
    tickId: position.tickId,
    colRaw,
    debtRaw,
    dustDebtRaw,
    finalAmount: netDebtRaw.gt(new BN(0)) ? colRaw : new BN(0),
    isSupplyOnlyPosition: positionTick === MIN_TICK,
    userLiquidationStatus,
    postLiquidationBranchId
  };
};
async function getAllBranches({
  vaultId,
  program
}) {
  const vaultState = await program.account.vaultState.fetch(
    getVaultState(vaultId)
  );
  const branchPromises = [];
  for (let i = 0; i <= vaultState.totalBranchId; i++) {
    branchPromises.push(
      program.account.branch.fetch(getBranch(vaultId, i)).catch(() => null)
    );
  }
  const branchResults = await Promise.all(branchPromises);
  const branches = branchResults.filter((branch) => branch !== null);
  return branches;
}
function getLiquidationStatus(positionTickId, tickData, tickIdData) {
  let isFullyLiquidated;
  let branchId;
  let connectionFactor;
  if (tickData.totalIds === positionTickId) {
    isFullyLiquidated = tickData.isFullyLiquidated === 1;
    branchId = tickData.liquidationBranchId;
    connectionFactor = tickData.debtFactor;
  } else {
    const setIndex = (positionTickId + 2) % 3;
    switch (setIndex) {
      case 0: {
        isFullyLiquidated = tickIdData.isFullyLiquidated1 === 1;
        branchId = tickIdData.liquidationBranchId1;
        connectionFactor = tickIdData.debtFactor1;
        break;
      }
      case 1: {
        isFullyLiquidated = tickIdData.isFullyLiquidated2 === 1;
        branchId = tickIdData.liquidationBranchId2;
        connectionFactor = tickIdData.debtFactor2;
        break;
      }
      default: {
        isFullyLiquidated = tickIdData.isFullyLiquidated3 === 1;
        branchId = tickIdData.liquidationBranchId3;
        connectionFactor = tickIdData.debtFactor3;
      }
    }
  }
  return { isFullyLiquidated, branchId, connectionFactor };
}
function processLiquidatedPosition({
  branches,
  branchId,
  initialConnectionFactor,
  initialDebtRaw
}) {
  let finalColRaw = new BN(0);
  let finalTick;
  const branchMap = new Map(
    branches.map((branch) => [branch.branchId, branch])
  );
  let currentBranchId = branchId;
  let currentConnectionFactor = initialConnectionFactor;
  let currentBranch = branchMap.get(currentBranchId);
  if (!currentBranch) {
    throw new Error(`Branch ${currentBranchId} not found`);
  }
  while (currentBranch.status === 2) {
    currentConnectionFactor = mulBigNumber(
      currentConnectionFactor,
      new BN(currentBranch.debtFactor.toString())
    );
    if (currentConnectionFactor.eq(MAX_MASK_DEBT_FACTOR)) {
      break;
    }
    currentBranchId = currentBranch.connectedBranchId;
    currentBranch = branchMap.get(currentBranchId);
    if (!currentBranch) {
      throw new Error(`Connected branch ${currentBranchId} not found`);
    }
  }
  let positionDebtRaw = new BN(0);
  if (currentBranch.status === 3 || currentConnectionFactor.eq(MAX_MASK_DEBT_FACTOR)) {
    positionDebtRaw = new BN(0);
    finalTick = MIN_TICK;
  } else {
    positionDebtRaw = mulDivNormal(
      initialDebtRaw,
      currentBranch.debtFactor,
      currentConnectionFactor
    );
    positionDebtRaw = positionDebtRaw.gt(initialDebtRaw.div(new BN(100))) ? positionDebtRaw.mul(new BN(9999)).div(new BN(1e4)) : new BN(0);
    if (positionDebtRaw.gt(new BN(0))) {
      finalTick = currentBranch.minimaTick;
      const ratioAtTick = getRatioAtTick(finalTick);
      const ratioOneLess = ratioAtTick.mul(new BN(1e4)).div(TICK_SPACING);
      const ratioLength = ratioAtTick.sub(ratioOneLess);
      const finalRatio = ratioOneLess.add(
        ratioLength.mul(new BN(currentBranch.minimaTickPartials)).div(X30)
      );
      finalColRaw = positionDebtRaw.mul(ZERO_TICK_SCALED_RATIO).div(finalRatio);
    } else finalTick = MIN_TICK;
  }
  return {
    finalTick,
    finalColRaw,
    finalDebtRaw: positionDebtRaw
  };
}
const getFinalPosition = async ({
  vaultId,
  currentPosition,
  newColAmount,
  newDebtAmount,
  program,
  connection,
  signer
}) => {
  program = program ?? getVaultsProgram({ connection, signer });
  const vaultConfig = await program.account.vaultConfig.fetch(
    getVaultConfig(vaultId)
  );
  const {
    vaultSupplyExchangePrice: supplyExPrice,
    vaultBorrowExchangePrice: borrowExPrice
  } = await getExchangePrices({
    vaultId,
    vaultConfig,
    connection,
    signer
  });
  const borrowFee = vaultConfig.borrowFee;
  let { colRaw, debtRaw, dustDebtRaw } = currentPosition;
  if (newColAmount.gt(new BN(0))) {
    const supplyRaw = newColAmount.mul(EXCHANGE_PRICES_PRECISION).div(supplyExPrice);
    colRaw = colRaw.add(supplyRaw);
  } else if (newColAmount.lt(new BN(0))) {
    let withdrawRaw = new BN(0);
    if (newColAmount.gt(MIN_I128$1)) {
      withdrawRaw = newColAmount.abs().mul(EXCHANGE_PRICES_PRECISION).div(supplyExPrice).sub(new BN(1));
      colRaw = colRaw.sub(withdrawRaw);
    } else if (newColAmount.eq(MIN_I128$1)) {
      withdrawRaw = colRaw.mul(supplyExPrice).div(EXCHANGE_PRICES_PRECISION).mul(new BN(-1)).add(new BN(1));
      colRaw = new BN(0);
    } else {
      throw new Error("Invalid newColAmount");
    }
  }
  if (newDebtAmount.gt(new BN(0))) {
    const borrowRaw = newDebtAmount.mul(EXCHANGE_PRICES_PRECISION).div(borrowExPrice).add(new BN(1));
    const feeAmount = borrowRaw.mul(new BN(borrowFee)).div(new BN(1e4));
    const borrowAmountWithFee = borrowRaw.add(feeAmount);
    debtRaw = debtRaw.add(borrowAmountWithFee);
  } else if (newDebtAmount.lt(new BN(0))) {
    if (newDebtAmount.gt(MIN_I128$1)) {
      const payback_amount = newDebtAmount.abs().mul(EXCHANGE_PRICES_PRECISION).div(borrowExPrice).add(new BN(1));
      debtRaw = debtRaw.sub(payback_amount);
    } else if (newDebtAmount.eq(MIN_I128$1)) {
      debtRaw = new BN(0);
    } else {
      throw new Error("Invalid newDebtAmount");
    }
  }
  const netDebtRaw = debtRaw.gt(dustDebtRaw) ? debtRaw.sub(dustDebtRaw) : new BN(0);
  let finalTick;
  let isSupplyOnlyPosition;
  if (netDebtRaw.eq(new BN(0)) || colRaw.eq(new BN(0))) {
    finalTick = MIN_TICK;
    isSupplyOnlyPosition = true;
  } else {
    const marginAdjustedDebt = netDebtRaw.mul(new BN(1000000001)).div(new BN(1e9)).add(new BN(1));
    const ratio = marginAdjustedDebt.mul(ZERO_TICK_SCALED_RATIO).div(colRaw);
    const baseTickAtRatio = getTickAtRatio(ratio);
    finalTick = baseTickAtRatio + 1;
    if (finalTick < MIN_TICK) {
      finalTick = MIN_TICK;
    } else if (finalTick > MAX_TICK) {
      finalTick = MAX_TICK;
    }
    isSupplyOnlyPosition = false;
  }
  return {
    tick: finalTick,
    tickId: currentPosition.tickId,
    colRaw,
    debtRaw,
    dustDebtRaw,
    finalAmount: netDebtRaw.gt(new BN(0)) ? colRaw : new BN(0),
    isSupplyOnlyPosition
  };
};
async function loadRelevantBranches(vaultId, vaultState, liquidationStatus, postLiquidationBranchId, program) {
  const addedBranchIds = /* @__PURE__ */ new Set();
  const currentBranchId = postLiquidationBranchId > 0 ? postLiquidationBranchId : vaultState.currentBranchId;
  let connectedBranchId = 0;
  if (currentBranchId > 0) {
    try {
      const currentBranch = await program.account.branch.fetch(
        getBranch(vaultId, currentBranchId)
      );
      if (currentBranch) {
        addedBranchIds.add(currentBranch.branchId);
        connectedBranchId = currentBranch.connectedBranchId;
      }
    } catch (error) {
      console.warn(`Failed to fetch current branch ${currentBranchId}:`, error);
    }
  }
  if (liquidationStatus) {
    while (connectedBranchId > 0) {
      try {
        const connectedBranch = await program.account.branch.fetch(
          getBranch(vaultId, connectedBranchId)
        );
        if (connectedBranch) {
          if (!addedBranchIds.has(connectedBranch.branchId))
            addedBranchIds.add(connectedBranch.branchId);
          connectedBranchId = connectedBranch.connectedBranchId;
        } else break;
      } catch (error) {
        console.warn(
          `Failed to fetch connected branch ${connectedBranchId}:`,
          error
        );
        break;
      }
    }
    if (!addedBranchIds.has(0)) addedBranchIds.add(0);
  }
  return [...addedBranchIds];
}
async function loadRelevantTicksHasDebtArrays(vaultId, topTick, existingPositionTick, finalTick, program) {
  const tickHasDebtArrays = /* @__PURE__ */ new Set();
  if (existingPositionTick == topTick) {
    let nextTickWithDebt = await findNextTickWithDebt(
      vaultId,
      topTick,
      program
    );
    let { arrayIndex: startIndex } = getTickIndices(nextTickWithDebt);
    let { arrayIndex: endIndex } = getTickIndices(topTick);
    let { arrayIndex: finalTickIndex } = getTickIndices(finalTick);
    let finalTickHasDebtPda = getTickHasDebt(vaultId, finalTickIndex);
    tickHasDebtArrays.add(finalTickHasDebtPda);
    if (endIndex < 15) endIndex++;
    try {
      for (let arrIdx = startIndex; arrIdx <= endIndex; arrIdx++)
        tickHasDebtArrays.add(getTickHasDebt(vaultId, arrIdx));
    } catch (error) {
      console.warn(`Error finding next tick with debt:`, error);
    }
  } else {
    let { arrayIndex: finalTickIndex } = getTickIndices(finalTick);
    let { arrayIndex: existingPositionTickIndex } = getTickIndices(existingPositionTick);
    tickHasDebtArrays.add(getTickHasDebt(vaultId, finalTickIndex));
    tickHasDebtArrays.add(
      getTickHasDebt(vaultId, existingPositionTickIndex)
    );
  }
  return [...tickHasDebtArrays];
}
async function getExchangePrices({
  vaultId,
  vaultConfig,
  connection,
  signer
}) {
  const program = new Program(vaultsIdl, { connection });
  const ix = await program.methods.getExchangePrices().accounts({
    vaultState: getVaultState(vaultId),
    vaultConfig: getVaultConfig(vaultId),
    supplyTokenReserves: getReserve(vaultConfig.supplyToken),
    borrowTokenReserves: getReserve(vaultConfig.borrowToken)
  }).instruction();
  const transaction = new Transaction().add(ix);
  const latestBlockHash = await connection.getLatestBlockhash();
  transaction.recentBlockhash = latestBlockHash.blockhash;
  transaction.feePayer = signer;
  const raw = await connection.simulateTransaction(transaction);
  if (raw.value.err && raw.value.err === "InvalidAccountForFee" && signer.toBase58() !== "HEyJLdMfZhhQ7FHCtjD5DWDFNFQhaeAVAsHeWqoY6dSD") {
    return await getExchangePrices({
      vaultId,
      vaultConfig,
      connection,
      signer: new PublicKey("HEyJLdMfZhhQ7FHCtjD5DWDFNFQhaeAVAsHeWqoY6dSD")
    });
  }
  const returnLog = raw.value.logs?.find(
    (log) => log.startsWith("Program return:")
  );
  if (!returnLog) {
    let error = new Error("No return data found in logs");
    error.simulation = raw.value;
    throw error;
  }
  const base64Data = returnLog.split(" ")[3];
  const buffer = Buffer.from(base64Data, "base64");
  const liquiditySupplyExchangePrice = new BN(buffer.subarray(0, 16), "le");
  const liquidityBorrowExchangePrice = new BN(buffer.subarray(16, 32), "le");
  const vaultSupplyExchangePrice = new BN(buffer.subarray(32, 48), "le");
  const vaultBorrowExchangePrice = new BN(buffer.subarray(48, 64), "le");
  return {
    liquiditySupplyExchangePrice,
    liquidityBorrowExchangePrice,
    vaultSupplyExchangePrice,
    vaultBorrowExchangePrice
  };
}
async function loadRelevantTicksHasDebtArraysLiquidate(vaultId, topTick, nextTick, program) {
  const { arrayIndex: topTickIndex } = getTickIndices(topTick);
  const { arrayIndex: nextTickIndex } = getTickIndices(nextTick);
  const promises = [];
  for (let arrIdx = topTickIndex; arrIdx >= nextTickIndex; arrIdx--) {
    promises.push(
      program.account.tickHasDebtArray.fetch(
        getTickHasDebt(vaultId, arrIdx)
      )
    );
  }
  const results = await Promise.allSettled(promises);
  const tickHasDebtArrays = results.filter((result) => result.status === "fulfilled").map(
    (result) => result.value
  );
  return tickHasDebtArrays;
}
async function loadRelevantBranchesForLiquidate(vaultId, vaultState, program) {
  const branches = [];
  const currentBranchId = vaultState.currentBranchId;
  if (currentBranchId > 0) {
    try {
      const currentBranch = await program.account.branch.fetch(
        getBranch(vaultId, currentBranchId)
      );
      if (currentBranch) branches.push(currentBranch);
    } catch (error) {
      console.warn(`Failed to fetch current branch ${currentBranchId}:`, error);
    }
  }
  let connectedBranchId = branches[0].connectedBranchId;
  const doesBranchExist = (branchId) => branches.some((b) => b.branchId === branchId);
  while (!doesBranchExist(connectedBranchId)) {
    try {
      const connectedBranch = await program.account.branch.fetch(
        getBranch(vaultId, connectedBranchId)
      );
      connectedBranchId = connectedBranch.connectedBranchId;
      if (connectedBranch) branches.push(connectedBranch);
    } catch (error) {
      console.warn(`Failed to fetch connected branch ${connectedBranchId}:`, error);
    }
  }
  if (!doesBranchExist(0)) branches.push({ branchId: 0 });
  return branches;
}
async function readOraclePrice({
  connection,
  signer,
  oracle: oracle$1
}) {
  const program = new Program(
    oracle,
    new AnchorProvider(connection, {
      signTransaction() {
        throw new Error("Not implemented");
      },
      signAllTransactions() {
        throw new Error("Not implemented");
      },
      publicKey: signer ?? new PublicKey("HEyJLdMfZhhQ7FHCtjD5DWDFNFQhaeAVAsHeWqoY6dSD")
    })
  );
  const oracleData = await program.account.oracle.fetch(oracle$1);
  let remainingAccounts = [];
  for (const source of oracleData.sources) {
    remainingAccounts.push({
      pubkey: source.source,
      isWritable: false,
      isSigner: false
    });
  }
  const [oraclePriceOperate, oraclePriceLiquidate] = await Promise.all([
    program.methods.getExchangeRateOperate(oracleData.nonce).accounts({ oracle: oracle$1 }).remainingAccounts(remainingAccounts).view(),
    program.methods.getExchangeRateLiquidate(oracleData.nonce).accounts({ oracle: oracle$1 }).remainingAccounts(remainingAccounts).view()
  ]);
  return {
    oraclePriceOperate,
    oraclePriceLiquidate,
    oracleSources: oracleData.sources
  };
}

const MPL_TOKEN_METADATA_PROGRAM_ID = new PublicKey(
  "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
);
const LIQUIDITY_PROGRAM_ID = new PublicKey(liquidity.address);
const MIN_I128 = new BN("170141183460469231731687303715884105728").neg();
async function getOtherInstructionsOperate(vaultId, vaultState, currentPosition, finalPosition, currentTick, program, signer) {
  const otherIxs = [];
  const tickToRead = [currentTick];
  let currentTickData;
  let finalTickData;
  tickToRead.push(currentPosition.tick);
  tickToRead.push(finalPosition.tick);
  if (tickToRead.length > 0) {
    const tickData = await program.account.tick.fetchMultiple(
      tickToRead.map((tick) => getTick(vaultId, tick))
    );
    currentTickData = tickData[0];
    finalTickData = tickData[2];
    for (const [i, tickDatum] of tickData.entries()) {
      if (!tickDatum) {
        const ix = await program.methods.initTick(vaultId, tickToRead[i]).accounts(getInitTickContext(vaultId, tickToRead[i], signer)).instruction();
        otherIxs.push(ix);
      }
    }
  }
  let newBranchId;
  if (vaultState.branchLiquidated) {
    newBranchId = vaultState.totalBranchId + 1;
    const newBranchData = await program.account.branch.fetch(
      getBranch(vaultId, newBranchId)
    );
    if (!newBranchData) {
      const ix = await program.methods.initBranch(vaultId, newBranchId).accounts(getInitBranchContext(vaultId, newBranchId, signer)).instruction();
      otherIxs.push(ix);
    }
  } else {
    newBranchId = vaultState.currentBranchId;
  }
  const newBranchPda = getBranch(vaultId, newBranchId);
  const currentTickIdDataPda = getTickIdLiquidation(
    vaultId,
    currentTick,
    currentTickData ? currentTickData.totalIds : 0
  );
  const tickIdsToRead = [
    {
      tick: currentTick,
      totalIds: currentTickData ? currentTickData.totalIds : 0
    }
  ];
  const finalTickIdDataPda = getTickIdLiquidation(
    vaultId,
    finalPosition.tick,
    finalTickData ? finalTickData.totalIds : 0
  );
  if (finalPosition.tick !== currentTick)
    if (finalTickData) {
      tickIdsToRead.push({
        tick: finalPosition.tick,
        totalIds: finalTickData.totalIds
      });
    } else {
      const context = await getInitTickIdLiquidationContext(
        vaultId,
        finalPosition.tick,
        signer,
        program
      );
      const ix = await program.methods.initTickIdLiquidation(vaultId, finalPosition.tick, 0).accounts(context).instruction();
      otherIxs.push(ix);
    }
  const tickIdData = await program.account.tickIdLiquidation.fetchMultiple(
    tickIdsToRead.map(
      ({ tick, totalIds }) => getTickIdLiquidation(vaultId, tick, totalIds)
    )
  );
  if (tickIdData.length > 0) {
    for (const [i, tickIdDatum] of tickIdData.entries()) {
      if (!tickIdDatum) {
        const ix = await program.methods.initTickIdLiquidation(
          vaultId,
          tickIdsToRead[i].tick,
          tickIdsToRead[i].totalIds
        ).accounts(
          await getInitTickIdLiquidationContext(
            vaultId,
            tickIdsToRead[i].tick,
            signer,
            program
          )
        ).instruction();
        otherIxs.push(ix);
      }
    }
  }
  return {
    otherIxs,
    newBranchPda,
    currentTickIdDataPda,
    finalTickIdDataPda
  };
}
const tickHelper = (tickValue) => {
  return tickValue === 0 ? INIT_TICK : tickValue;
};
async function getRemainingAccountsOperate(vaultId, vaultState, vaultConfig, finalPositionTick, existingPositionTick, liquidationStatus, postLiquidationBranchId, program) {
  const remainingAccounts = [];
  const oracleProgram = new Program(oracle, program.provider);
  const [oracleData, branches, tickHasDebt] = await Promise.all([
    oracleProgram.account.oracle.fetch(new PublicKey(vaultConfig.oracle)),
    // Add branch accounts (next 10 remaining accounts)
    loadRelevantBranches(
      vaultId,
      vaultState,
      liquidationStatus,
      postLiquidationBranchId,
      program
    ),
    loadRelevantTicksHasDebtArrays(
      vaultId,
      tickHelper(vaultState.topmostTick),
      existingPositionTick,
      finalPositionTick,
      program
    )
  ]);
  const sourceLength = oracleData.sources.length;
  for (const source of oracleData.sources)
    remainingAccounts.push({
      pubkey: new PublicKey(source.source),
      isWritable: false,
      isSigner: false
    });
  const branchLength = branches.length;
  for (const branch of branches) {
    remainingAccounts.push({
      pubkey: getBranch(vaultId, branch),
      isWritable: true,
      isSigner: false
    });
  }
  const tickHasDebtLength = tickHasDebt.length;
  for (const tickHasDebtArray of tickHasDebt)
    remainingAccounts.push({
      pubkey: tickHasDebtArray,
      isWritable: true,
      isSigner: false
    });
  const remainingAccountsIndices = [
    sourceLength,
    branchLength,
    tickHasDebtLength
  ];
  return {
    remainingAccounts,
    remainingAccountsIndices
  };
}
async function getOperateContext({
  vaultId,
  positionId,
  program,
  connection,
  signer,
  positionOwner = signer,
  colAmount: newCol,
  debtAmount: newDebt,
  recipient
}) {
  program = program ?? getVaultsProgram({ connection, signer });
  const [vaultState, vaultConfig, vaultMetadata] = await Promise.all([
    program.account.vaultState.fetch(getVaultState(vaultId)),
    program.account.vaultConfig.fetch(getVaultConfig(vaultId)),
    program.account.vaultMetadata.fetch(getVaultMetadata(vaultId))
  ]);
  const [supplyTokenProgram, borrowTokenProgram] = await Promise.all([
    getAccountOwner(vaultConfig.supplyToken, connection),
    getAccountOwner(vaultConfig.borrowToken, connection)
  ]);
  const vaultSupplyDecimals = vaultMetadata.supplyMintDecimals;
  const vaultBorrowDecimals = vaultMetadata.borrowMintDecimals;
  if (newCol.gt(MIN_I128)) {
    const decimalsDelta = vaultSupplyDecimals < 9 ? 9 - vaultSupplyDecimals : 0;
    newCol = newCol.mul(new BN(10).pow(new BN(decimalsDelta)));
  }
  if (newDebt.gt(MIN_I128)) {
    const decimalsDelta = vaultBorrowDecimals < 9 ? 9 - vaultBorrowDecimals : 0;
    newDebt = newDebt.mul(new BN(10).pow(new BN(decimalsDelta)));
  }
  const positionData = positionId === 0 ? {
    nftId: vaultState.nextPositionId,
    positionMint: new PublicKey(0),
    isSupplyOnlyPosition: 1,
    tick: -2147483648,
    tickId: 0,
    lastUpdateTimestamp: new BN(0),
    supplyAmount: new BN(0),
    dustDebtAmount: new BN(0)} : await program.account.position.fetch(
    getPosition(vaultId, positionId)
  );
  let existingPositionTick = positionData.tick;
  const currentPosition = await getCurrentPositionState({
    vaultId,
    position: positionData,
    program
  });
  if (existingPositionTick === -2147483648) {
    existingPositionTick = currentPosition.tick;
  }
  const currentPositionTickPda = getTick(
    vaultId,
    existingPositionTick
  );
  const finalPosition = await getFinalPosition({
    vaultId,
    currentPosition,
    newColAmount: newCol,
    newDebtAmount: newDebt,
    program,
    connection,
    signer
  });
  const { otherIxs, newBranchPda, currentTickIdDataPda, finalTickIdDataPda } = await getOtherInstructionsOperate(
    vaultId,
    vaultState,
    currentPosition,
    finalPosition,
    existingPositionTick,
    program,
    signer
  );
  const { remainingAccounts, remainingAccountsIndices } = await getRemainingAccountsOperate(
    vaultId,
    vaultState,
    vaultConfig,
    finalPosition.tick,
    existingPositionTick,
    currentPosition.userLiquidationStatus,
    currentPosition.postLiquidationBranchId,
    program
  );
  const accounts = {
    signer,
    signerSupplyTokenAccount: getAssociatedTokenAddressSync(
      vaultConfig.supplyToken,
      signer,
      false,
      supplyTokenProgram
    ),
    signerBorrowTokenAccount: getAssociatedTokenAddressSync(
      vaultConfig.borrowToken,
      signer,
      false,
      borrowTokenProgram
    ),
    recipient: recipient ?? null,
    recipientSupplyTokenAccount: recipient ? getAssociatedTokenAddressSync(
      vaultConfig.supplyToken,
      recipient,
      false,
      supplyTokenProgram
    ) : null,
    recipientBorrowTokenAccount: recipient ? getAssociatedTokenAddressSync(
      vaultConfig.borrowToken,
      recipient,
      false,
      borrowTokenProgram
    ) : null,
    vaultConfig: getVaultConfig(vaultId),
    vaultState: getVaultState(vaultId),
    supplyToken: vaultConfig.supplyToken,
    borrowToken: vaultConfig.borrowToken,
    oracle: new PublicKey(vaultConfig.oracle),
    position: getPosition(vaultId, positionData.nftId),
    positionTokenAccount: getPositionTokenAccount(
      vaultId,
      positionData.nftId,
      positionOwner
    ),
    currentPositionTick: currentPositionTickPda,
    finalPositionTick: getTick(vaultId, finalPosition.tick),
    currentPositionTickId: currentTickIdDataPda,
    finalPositionTickId: finalTickIdDataPda,
    newBranch: newBranchPda,
    supplyTokenReservesLiquidity: getLiquidityReserve(
      vaultConfig.supplyToken
    ),
    borrowTokenReservesLiquidity: getLiquidityReserve(
      vaultConfig.borrowToken
    ),
    vaultSupplyPositionOnLiquidity: getUserSupplyPosition(
      vaultConfig.supplyToken,
      getVaultConfig(vaultId)
    ),
    vaultBorrowPositionOnLiquidity: getUserBorrowPosition(
      vaultConfig.borrowToken,
      getVaultConfig(vaultId)
    ),
    supplyRateModel: getRateModel(vaultConfig.supplyToken),
    borrowRateModel: getRateModel(vaultConfig.borrowToken),
    supplyTokenClaimAccount: null,
    borrowTokenClaimAccount: null,
    liquidity: getLiquidity(),
    liquidityProgram: LIQUIDITY_PROGRAM_ID,
    vaultSupplyTokenAccount: getAssociatedTokenAddressSync(
      vaultConfig.supplyToken,
      getLiquidity(),
      true,
      supplyTokenProgram
    ),
    vaultBorrowTokenAccount: getAssociatedTokenAddressSync(
      vaultConfig.borrowToken,
      getLiquidity(),
      true,
      borrowTokenProgram
    ),
    oracleProgram: new PublicKey(vaultConfig.oracleProgram),
    supplyTokenProgram,
    borrowTokenProgram,
    associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
    systemProgram: SystemProgram.programId
  };
  return {
    nftId: positionData.nftId,
    accounts,
    remainingAccounts,
    initPositionIx: positionId === 0 ? await program.methods.initPosition(vaultId, positionData.nftId).accounts(
      getInitPositionContext(vaultId, positionData.nftId, signer)
    ).instruction() : null,
    otherIxs,
    remainingAccountsIndices,
    lookupTable: vaultMetadata.lookupTable
  };
}
async function getInitPositionIx({
  vaultId,
  connection,
  signer
}) {
  const program = getVaultsProgram({ connection, signer });
  const vaultState = await program.account.vaultState.fetch(
    getVaultState(vaultId)
  );
  return {
    ix: await program.methods.initPosition(vaultId, vaultState.nextPositionId).accounts(
      getInitPositionContext(vaultId, vaultState.nextPositionId, signer)
    ).instruction(),
    nftId: vaultState.nextPositionId
  };
}
function getInitPositionContext(vaultId, positionId, signer) {
  return {
    signer,
    vaultAdmin: getVaultAdmin(),
    vaultState: getVaultState(vaultId),
    position: getPosition(vaultId, positionId),
    positionMint: getPositionMint(vaultId, positionId),
    positionTokenAccount: getPositionTokenAccount(
      vaultId,
      positionId,
      signer
    ),
    tokenProgram: TOKEN_PROGRAM_ID,
    metadataAccount: getPositionMetadata(vaultId, positionId),
    associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
    systemProgram: SystemProgram.programId,
    sysvarInstruction: SYSVAR_INSTRUCTIONS_PUBKEY,
    metadataProgram: MPL_TOKEN_METADATA_PROGRAM_ID,
    rent: SYSVAR_RENT_PUBKEY
  };
}
const getOperateIx = async ({
  vaultId,
  positionId,
  colAmount,
  debtAmount,
  connection,
  signer,
  recipient,
  positionOwner
}) => {
  const program = getVaultsProgram({ connection, signer });
  const {
    accounts,
    remainingAccounts,
    remainingAccountsIndices,
    initPositionIx,
    otherIxs,
    lookupTable,
    nftId
  } = await getOperateContext({
    vaultId,
    positionId,
    colAmount,
    debtAmount,
    signer,
    positionOwner,
    connection,
    recipient,
    program
  });
  const [operateIx, addressLookupTable] = await Promise.all([
    program.methods.operate(
      colAmount,
      debtAmount,
      { direct: {} },
      Buffer.from(remainingAccountsIndices)
    ).accounts(accounts).remainingAccounts(remainingAccounts).instruction(),
    connection.getAddressLookupTable(lookupTable)
  ]);
  return {
    nftId,
    accounts,
    remainingAccounts,
    remainingAccountsIndices,
    addressLookupTableAddresses: lookupTable ? [lookupTable] : [],
    addressLookupTableAccounts: addressLookupTable.value ? [addressLookupTable.value] : [],
    ixs: initPositionIx ? [initPositionIx, ...otherIxs, operateIx] : [...otherIxs, operateIx]
  };
};
function getInitBranchContext(vaultId, branchId, signer) {
  return {
    signer,
    vaultConfig: getVaultConfig(vaultId),
    branch: getBranch(vaultId, branchId),
    systemProgram: SystemProgram.programId
  };
}
function getInitTickContext(vaultId, tick, signer) {
  return {
    signer,
    vaultConfig: getVaultConfig(vaultId),
    tickData: getTick(vaultId, tick),
    systemProgram: SystemProgram.programId
  };
}
async function getInitTickIdLiquidationContext(vaultId, tick, signer, program) {
  const tickData = await program.account.tick.fetch(getTick(vaultId, tick)).catch(() => null);
  if (!tickData) {
    return {
      signer,
      vaultConfig: getVaultConfig(vaultId),
      tickIdLiquidation: getTickIdLiquidation(vaultId, tick, 0),
      tickData: getTick(vaultId, tick),
      systemProgram: SystemProgram.programId
    };
  }
  return {
    signer,
    vaultConfig: getVaultConfig(vaultId),
    tickIdLiquidation: getTickIdLiquidation(
      vaultId,
      tick,
      tickData.totalIds
    ),
    tickData: getTick(vaultId, tick),
    systemProgram: SystemProgram.programId
  };
}
async function getLiquidateContext({
  vaultId,
  to,
  program,
  connection,
  signer
}) {
  program = program ?? getVaultsProgram({ connection, signer });
  const [vaultState, vaultConfig, vaultMetadata] = await Promise.all([
    program.account.vaultState.fetch(getVaultState(vaultId)),
    program.account.vaultConfig.fetch(getVaultConfig(vaultId)),
    program.account.vaultMetadata.fetch(getVaultMetadata(vaultId))
  ]);
  const [supplyTokenProgram, borrowTokenProgram] = await Promise.all([
    getAccountOwner(vaultConfig.supplyToken, connection),
    getAccountOwner(vaultConfig.borrowToken, connection)
  ]);
  const { arrayIndex } = getTickIndices(vaultState.topmostTick);
  let { otherIxs, newBranchPda } = await getOtherInstructionsLiquidate(
    vaultId,
    vaultState,
    program,
    signer
  );
  const {
    remainingAccounts,
    remainingAccountsIndices,
    otherIxs: finalOtherIxs
  } = await getRemainingAccountsLiquidate(
    vaultId,
    vaultState,
    vaultConfig,
    otherIxs,
    program,
    connection,
    signer
  );
  return {
    accounts: {
      signer,
      signerTokenAccount: getAssociatedTokenAddressSync(
        vaultConfig.borrowToken,
        signer,
        false,
        borrowTokenProgram
      ),
      to,
      toTokenAccount: getAssociatedTokenAddressSync(
        vaultConfig.supplyToken,
        to,
        false,
        supplyTokenProgram
      ),
      vaultAdmin: getVaultAdmin(),
      vaultConfig: getVaultConfig(vaultId),
      vaultState: getVaultState(vaultId),
      supplyToken: vaultConfig.supplyToken,
      borrowToken: vaultConfig.borrowToken,
      oracle: new PublicKey(vaultConfig.oracle),
      tickHasDebt: getTickHasDebt(vaultId, arrayIndex),
      newBranch: newBranchPda,
      supplyTokenReservesLiquidity: getLiquidityReserve(
        vaultConfig.supplyToken
      ),
      borrowTokenReservesLiquidity: getLiquidityReserve(
        vaultConfig.borrowToken
      ),
      vaultSupplyPositionOnLiquidity: getUserSupplyPosition(
        vaultConfig.supplyToken,
        getVaultConfig(vaultId)
      ),
      vaultBorrowPositionOnLiquidity: getUserBorrowPosition(
        vaultConfig.borrowToken,
        getVaultConfig(vaultId)
      ),
      supplyRateModel: getRateModel(vaultConfig.supplyToken),
      borrowRateModel: getRateModel(vaultConfig.borrowToken),
      supplyTokenClaimAccount: getClaimAccount(
        vaultConfig.supplyToken,
        getVaultConfig(vaultId)
      ),
      borrowTokenClaimAccount: getClaimAccount(
        vaultConfig.borrowToken,
        getVaultConfig(vaultId)
      ),
      liquidity: getLiquidity(),
      liquidityProgram: LIQUIDITY_PROGRAM_ID,
      vaultSupplyTokenAccount: getAssociatedTokenAddressSync(
        vaultConfig.supplyToken,
        getLiquidity(),
        true,
        supplyTokenProgram
      ),
      vaultBorrowTokenAccount: getAssociatedTokenAddressSync(
        vaultConfig.borrowToken,
        getLiquidity(),
        true,
        borrowTokenProgram
      ),
      oracleProgram: new PublicKey(vaultConfig.oracleProgram),
      supplyTokenProgram,
      borrowTokenProgram,
      systemProgram: SystemProgram.programId,
      associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID
    },
    remainingAccounts,
    otherIxs: finalOtherIxs,
    remainingAccountsIndices,
    lookupTable: vaultMetadata.lookupTable
  };
}
const getLiquidateIx = async ({
  vaultId,
  debtAmount,
  colPerUnitDebt = new BN(0),
  absorb = false,
  signer,
  to = signer,
  connection
}) => {
  const program = getVaultsProgram({ connection, signer });
  const {
    accounts,
    remainingAccounts,
    remainingAccountsIndices,
    otherIxs,
    lookupTable
  } = await getLiquidateContext({
    vaultId,
    to,
    program,
    signer,
    connection
  });
  const ixs = [];
  if (otherIxs.length > 0) {
    ixs.push(...otherIxs);
  }
  const [ix, addressLookupTable] = await Promise.all([
    program.methods.liquidate(
      debtAmount,
      colPerUnitDebt,
      absorb,
      { direct: {} },
      Buffer.from(remainingAccountsIndices)
    ).accounts(accounts).remainingAccounts(remainingAccounts).instruction(),
    connection.getAddressLookupTable(lookupTable)
  ]);
  ixs.push(ix);
  return {
    accounts,
    remainingAccounts,
    remainingAccountsIndices,
    ixs,
    addressLookupTableAddresses: lookupTable ? [lookupTable] : [],
    addressLookupTableAccounts: addressLookupTable.value ? [addressLookupTable.value] : []
  };
};
async function getOtherInstructionsLiquidate(vaultId, vaultState, program, signer) {
  const otherIxs = [];
  let newBranchId = vaultState.branchLiquidated === 1 ? vaultState.totalBranchId + 1 : vaultState.currentBranchId;
  let newBranchPda = getBranch(vaultId, newBranchId);
  const [newBranchData, tickData] = await Promise.all([
    program.account.branch.fetch(newBranchPda).catch(() => null),
    // might be possible that liquidation ends on a tick that is not initialized
    program.account.tick.fetch(getTick(vaultId, vaultState.topmostTick)).catch(() => null)
  ]);
  if (!newBranchData) {
    const ix = await program.methods.initBranch(vaultId, newBranchId).accounts(getInitBranchContext(vaultId, newBranchId, signer)).instruction();
    otherIxs.push(ix);
  }
  if (!tickData) {
    const ix = await program.methods.initTick(vaultId, vaultState.topmostTick).accounts(getInitTickContext(vaultId, vaultState.topmostTick, signer)).instruction();
    otherIxs.push(ix);
  }
  return {
    otherIxs,
    newBranchPda
  };
}
async function loadRelevantTicksForLiquidate(vaultId, vaultState, liquidationTick, program) {
  const ticks = [];
  let topTick = vaultState.topmostTick;
  if (topTick > liquidationTick)
    try {
      const topTickData = await program.account.tick.fetch(
        getTick(vaultId, topTick)
      );
      if (topTickData) ticks.push({ ...topTickData, tick: topTick });
    } catch {
    }
  let nextTick = MIN_TICK$1;
  try {
    nextTick = await findNextTickWithDebt(vaultId, topTick, program);
  } catch {
  }
  const doesTickExist = (tick) => ticks.some((t) => t.tick === tick);
  while (nextTick > liquidationTick && !doesTickExist(nextTick)) {
    try {
      const nextTickData = await program.account.tick.fetch(
        getTick(vaultId, nextTick)
      );
      if (nextTickData) ticks.push({ ...nextTickData, tick: nextTick });
      else throw new Error("Tick not found to load");
      nextTick = await findNextTickWithDebt(vaultId, nextTick, program);
    } catch {
    }
  }
  return { ticks, nextTick };
}
async function getRemainingAccountsLiquidate(vaultId, vaultState, vaultConfig, otherIxs, program, connection, signer) {
  const remainingAccounts = [];
  const { oraclePriceLiquidate, oracleSources } = await readOraclePrice({
    oracle: vaultConfig.oracle,
    connection
    // signer,
  });
  const liquidationRatio = new BN(oraclePriceLiquidate).mul(new BN(281474976710656)).div(new BN(10).pow(new BN(15)));
  const liquidationThresholdRatio = liquidationRatio.mul(new BN(vaultConfig.liquidationThreshold)).div(new BN(10).pow(new BN(3)));
  const liquidationTick = getTickAtRatio(liquidationThresholdRatio);
  for (const source of oracleSources) {
    remainingAccounts.push({
      pubkey: source.source,
      isWritable: false,
      isSigner: false
    });
  }
  const [branches, { ticks: tickAccounts, nextTick }] = await Promise.all([
    loadRelevantBranchesForLiquidate(vaultId, vaultState, program),
    loadRelevantTicksForLiquidate(
      vaultId,
      vaultState,
      liquidationTick,
      program
    )
  ]);
  const tickHasDebt = await loadRelevantTicksHasDebtArraysLiquidate(
    vaultId,
    vaultState.topmostTick,
    nextTick,
    program
  );
  for (const branch of branches) {
    remainingAccounts.push({
      pubkey: getBranch(vaultId, branch.branchId),
      isWritable: true,
      isSigner: false
    });
  }
  const tickToInit = [];
  const existingTicks = await Promise.all(
    tickAccounts.map(
      (tickData) => program.account.tick.fetch(getTick(vaultId, tickData.tick)).catch(() => null)
    )
  );
  const initInstructions = await Promise.all(
    tickAccounts.map(async (tickData, index) => {
      const existingTick = existingTicks[index];
      if (!existingTick && !tickToInit.includes(tickData.tick)) {
        tickToInit.push(tickData.tick);
        return program.methods.initTick(vaultId, tickData.tick).accounts(getInitTickContext(vaultId, tickData.tick, signer)).instruction();
      }
      return null;
    })
  );
  for (const ix of initInstructions) {
    if (ix) {
      otherIxs.push(ix);
    }
  }
  for (const tickData of tickAccounts) {
    remainingAccounts.push({
      pubkey: getTick(vaultId, tickData.tick),
      isWritable: true,
      isSigner: false
    });
  }
  for (const tickHasDebtArray of tickHasDebt) {
    remainingAccounts.push({
      pubkey: getTickHasDebt(vaultId, tickHasDebtArray.index),
      isWritable: true,
      isSigner: false
    });
  }
  const remainingAccountsIndices = [
    oracleSources.length,
    branches.length,
    tickAccounts.length,
    tickHasDebt.length
  ];
  return {
    remainingAccounts,
    otherIxs,
    remainingAccountsIndices
  };
}

export { findNextTickWithDebt as A, INIT_TICK as I, MIN_TICK$1 as M, TICK_HAS_DEBT_ARRAY_SIZE as T, ZERO_TICK_SCALED_RATIO$1 as Z, getVaultsProgram as a, getOperateContext as b, getInitPositionIx as c, getInitPositionContext as d, getOperateIx as e, getLiquidateContext as f, getLiquidateIx as g, getAccountOwner as h, getCurrentPosition as i, getCurrentPositionState as j, getFinalPosition as k, loadRelevantBranches as l, loadRelevantTicksHasDebtArrays as m, loadRelevantTicksHasDebtArraysLiquidate as n, loadRelevantBranchesForLiquidate as o, MAX_TICK$1 as p, TICKS_PER_TICK_HAS_DEBT as q, readOraclePrice as r, TICK_HAS_DEBT_CHILDREN_SIZE as s, TICK_HAS_DEBT_CHILDREN_SIZE_IN_BITS as t, TOTAL_INDICES_NEEDED as u, getRatioAtTick as v, getTickAtRatio as w, getFirstTickForIndex as x, getTickIndices as y, readTickHasDebtArray as z };
