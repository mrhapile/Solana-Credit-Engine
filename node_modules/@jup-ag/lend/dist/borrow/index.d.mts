import { V as Vaults, L as LiquidateParams } from '../shared/lend.DNFQlLzM.mjs';
export { C as ConnectionParams, I as InitPositionIxParams, e as LiquidateContextParams, O as OperateContextParams, a as OperateParams, c as getInitPositionContext, b as getInitPositionIx, f as getLiquidateContext, h as getLiquidateIx, g as getOperateContext, d as getOperateIx } from '../shared/lend.DNFQlLzM.mjs';
import { Program } from '@coral-xyz/anchor';
import BN from 'bn.js';
import * as _solana_web3_js from '@solana/web3.js';
import { Connection, PublicKey } from '@solana/web3.js';

type PositionData = Awaited<ReturnType<Program<Vaults>["account"]["position"]["fetch"]>>;
type VaultState = Awaited<ReturnType<Program<Vaults>["account"]["vaultState"]["fetch"]>>;
type GetCurrentPositionParams = {
    vaultId: number;
    positionId: number;
    connection: Connection;
};
type GetCurrentPositionStateParams = {
    vaultId: number;
    position: PositionData;
    program: Program<Vaults>;
};
declare const getVaultsProgram: ({ connection, signer, }: {
    connection: Connection;
    signer: PublicKey;
}) => Program<Vaults>;
declare const INIT_TICK = -2147483648;
declare const getAccountOwner: (account: PublicKey, connection: Connection) => Promise<PublicKey>;
declare const getCurrentPosition: ({ vaultId, positionId, connection, }: GetCurrentPositionParams) => Promise<{
    tick: number;
    tickId: number;
    colRaw: BN;
    finalAmount: BN;
    debtRaw: BN;
    dustDebtRaw: BN;
    isSupplyOnlyPosition: boolean;
    userLiquidationStatus: boolean;
    postLiquidationBranchId: number;
}>;
declare const getCurrentPositionState: ({ vaultId, position, program, }: GetCurrentPositionStateParams) => Promise<{
    tick: number;
    tickId: number;
    colRaw: BN;
    finalAmount: BN;
    debtRaw: BN;
    dustDebtRaw: BN;
    isSupplyOnlyPosition: boolean;
    userLiquidationStatus: boolean;
    postLiquidationBranchId: number;
}>;
declare const getFinalPosition: ({ vaultId, currentPosition, newColAmount, newDebtAmount, program, connection, signer, }: {
    vaultId: number;
    currentPosition: Awaited<ReturnType<typeof getCurrentPositionState>>;
    newColAmount: BN;
    newDebtAmount: BN;
    program?: Program<Vaults>;
    connection: Connection;
    signer: PublicKey;
}) => Promise<{
    tick: number;
    tickId: number;
    colRaw: BN;
    debtRaw: BN;
    dustDebtRaw: BN;
    finalAmount: BN;
    isSupplyOnlyPosition: boolean;
}>;
declare function loadRelevantBranches(vaultId: number, vaultState: VaultState, liquidationStatus: boolean, postLiquidationBranchId: number, program: Program<Vaults>): Promise<number[]>;
declare function loadRelevantTicksHasDebtArrays(vaultId: number, topTick: number, existingPositionTick: number, finalTick: number, program: Program<Vaults>): Promise<PublicKey[]>;
declare function loadRelevantTicksHasDebtArraysLiquidate(vaultId: number, topTick: number, nextTick: number, program: Program<Vaults>): Promise<{
    vaultId: number;
    index: number;
    tickHasDebt: {
        childrenBits: number[];
    }[];
}[]>;
declare function loadRelevantBranchesForLiquidate(vaultId: number, vaultState: any, program: Program<Vaults>): Promise<any[]>;
declare function readOraclePrice({ connection, signer, oracle, }: {
    connection: Connection;
    signer?: PublicKey;
    oracle: PublicKey;
}): Promise<{
    oraclePriceOperate: any;
    oraclePriceLiquidate: any;
    oracleSources: {
        source: PublicKey;
        invert: boolean;
        multiplier: BN;
        divisor: BN;
        sourceType: ({
            stakePool?: undefined;
            msolPool?: undefined;
            redstone?: undefined;
            chainlink?: undefined;
            singlePool?: undefined;
        } & {
            pyth: Record<string, never>;
        }) | ({
            pyth?: undefined;
            msolPool?: undefined;
            redstone?: undefined;
            chainlink?: undefined;
            singlePool?: undefined;
        } & {
            stakePool: Record<string, never>;
        }) | ({
            pyth?: undefined;
            stakePool?: undefined;
            redstone?: undefined;
            chainlink?: undefined;
            singlePool?: undefined;
        } & {
            msolPool: Record<string, never>;
        }) | ({
            pyth?: undefined;
            stakePool?: undefined;
            msolPool?: undefined;
            chainlink?: undefined;
            singlePool?: undefined;
        } & {
            redstone: Record<string, never>;
        }) | ({
            pyth?: undefined;
            stakePool?: undefined;
            msolPool?: undefined;
            redstone?: undefined;
            singlePool?: undefined;
        } & {
            chainlink: Record<string, never>;
        }) | ({
            pyth?: undefined;
            stakePool?: undefined;
            msolPool?: undefined;
            redstone?: undefined;
            chainlink?: undefined;
        } & {
            singlePool: Record<string, never>;
        });
    }[];
}>;

declare const MIN_TICK = -16383;
declare const MAX_TICK = 16383;
declare const ZERO_TICK_SCALED_RATIO: BN;
declare const TICK_HAS_DEBT_ARRAY_SIZE = 8;
declare const TICKS_PER_TICK_HAS_DEBT: number;
declare const TICK_HAS_DEBT_CHILDREN_SIZE = 32;
declare const TICK_HAS_DEBT_CHILDREN_SIZE_IN_BITS = 256;
declare const TOTAL_INDICES_NEEDED = 16;
declare function getRatioAtTick(tick: number): BN;
declare function getTickAtRatio(ratioX48: BN): number;
declare function getFirstTickForIndex(index: number): number;
declare function getTickIndices(tick: number): {
    arrayIndex: number;
    mapIndex: number;
    byteIndex: number;
    bitIndex: number;
};
declare function readTickHasDebtArray({ vaultId, index, program, }: {
    vaultId: number;
    index: number;
    program: Program<Vaults>;
}): Promise<{
    vaultId: number;
    index: number;
    tickHasDebt: {
        childrenBits: number[];
    }[];
}>;
declare function findNextTickWithDebt(vaultId: number, startTick: number, program: Program<Vaults>): Promise<number>;

declare const simulateLiquidate: (params: LiquidateParams) => Promise<_solana_web3_js.SimulatedTransactionResponse>;
declare const getLiquidations: (params: Omit<LiquidateParams, "debtAmount">) => Promise<{
    amtOut: string;
    amtIn: string;
    topTick: string;
}[]>;
declare const getAllLiquidations: (params: Omit<LiquidateParams, "debtAmount" | "vaultId">) => Promise<{
    vaultId: number;
    liquidations: never[] | {
        amtOut: string;
        amtIn: string;
        topTick: string;
    }[];
}[]>;

export { INIT_TICK, LiquidateParams, MAX_TICK, MIN_TICK, TICKS_PER_TICK_HAS_DEBT, TICK_HAS_DEBT_ARRAY_SIZE, TICK_HAS_DEBT_CHILDREN_SIZE, TICK_HAS_DEBT_CHILDREN_SIZE_IN_BITS, TOTAL_INDICES_NEEDED, ZERO_TICK_SCALED_RATIO, findNextTickWithDebt, getAccountOwner, getAllLiquidations, getCurrentPosition, getCurrentPositionState, getFinalPosition, getFirstTickForIndex, getLiquidations, getRatioAtTick, getTickAtRatio, getTickIndices, getVaultsProgram, loadRelevantBranches, loadRelevantBranchesForLiquidate, loadRelevantTicksHasDebtArrays, loadRelevantTicksHasDebtArraysLiquidate, readOraclePrice, readTickHasDebtArray, simulateLiquidate };
