import { g as getLiquidateIx, a as getVaultsProgram } from '../shared/lend.yP9-PjAh.mjs';
export { I as INIT_TICK, p as MAX_TICK, M as MIN_TICK, q as TICKS_PER_TICK_HAS_DEBT, T as TICK_HAS_DEBT_ARRAY_SIZE, s as TICK_HAS_DEBT_CHILDREN_SIZE, t as TICK_HAS_DEBT_CHILDREN_SIZE_IN_BITS, u as TOTAL_INDICES_NEEDED, Z as ZERO_TICK_SCALED_RATIO, A as findNextTickWithDebt, h as getAccountOwner, i as getCurrentPosition, j as getCurrentPositionState, k as getFinalPosition, x as getFirstTickForIndex, d as getInitPositionContext, c as getInitPositionIx, f as getLiquidateContext, b as getOperateContext, e as getOperateIx, v as getRatioAtTick, w as getTickAtRatio, y as getTickIndices, l as loadRelevantBranches, o as loadRelevantBranchesForLiquidate, m as loadRelevantTicksHasDebtArrays, n as loadRelevantTicksHasDebtArraysLiquidate, r as readOraclePrice, z as readTickHasDebtArray } from '../shared/lend.yP9-PjAh.mjs';
import { PublicKey, TransactionMessage, ComputeBudgetProgram, VersionedTransaction } from '@solana/web3.js';
import BN from 'bn.js';
import { g as getVaultAdmin } from '../shared/lend.C2-jCLFw.mjs';
import '@coral-xyz/anchor';
import '../shared/lend.CioR9-te.mjs';
import '@solana/spl-token';
import '../shared/lend.BzG5ldOV.mjs';

const simulateLiquidate = async (params) => {
  const { connection, signer } = params;
  const { ixs, addressLookupTableAccounts } = await getLiquidateIx({
    ...params,
    signer,
    to: new PublicKey("11111111111111111111111111111111")
  });
  const latestBlockhash = await connection.getLatestBlockhash();
  const messageV0 = new TransactionMessage({
    payerKey: signer,
    recentBlockhash: latestBlockhash.blockhash,
    instructions: [
      ComputeBudgetProgram.setComputeUnitLimit({
        units: 1e6
      }),
      ...ixs
    ]
  }).compileToV0Message(addressLookupTableAccounts);
  const transaction = new VersionedTransaction(messageV0);
  const raw = await connection.simulateTransaction(transaction);
  return raw.value;
};
const getLiquidations = async (params) => {
  const simulation = await simulateLiquidate({
    ...params,
    debtAmount: new BN(2).pow(new BN(64)).sub(new BN(1))
  });
  return parseVaultLiquidations(simulation.logs || []);
};
const getAllLiquidations = async (params) => {
  const program = getVaultsProgram({
    connection: params.connection,
    signer: params.signer || new PublicKey("HEyJLdMfZhhQ7FHCtjD5DWDFNFQhaeAVAsHeWqoY6dSD")
  });
  const { nextVaultId: totalVaults } = await program.account.vaultAdmin.fetch(
    getVaultAdmin()
  );
  const vaultIds = Array.from({ length: totalVaults - 1 }, (_, i) => i + 1);
  const results = [];
  for (let i = 0; i < vaultIds.length; i += 20) {
    const chunk = vaultIds.slice(i, i + 20);
    const chunkResults = await Promise.all(
      chunk.map(async (vaultId) => ({
        vaultId,
        liquidations: await getLiquidations({ ...params, vaultId }).catch(
          () => []
        )
      }))
    );
    results.push(...chunkResults);
  }
  return results;
};
function parseVaultLiquidations(logs) {
  const results = [];
  for (const log of logs) {
    if (log.includes("VaultLiquidationResult:")) {
      const match = log.match(/VaultLiquidationResult: \[([^\]]+)\]/);
      if (match && match[1]) {
        const values = match[1].split(", ").map((v) => v.trim());
        const [amtOut, amtIn, topTick] = values;
        if (amtIn && amtIn != "0" && amtOut && amtOut != "0" && topTick) {
          results.push({
            amtOut,
            amtIn,
            topTick
          });
        }
      }
    }
  }
  return results;
}

export { getAllLiquidations, getLiquidateIx, getLiquidations, getVaultsProgram, simulateLiquidate };
