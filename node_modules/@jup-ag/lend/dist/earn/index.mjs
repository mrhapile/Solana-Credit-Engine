import { SYSVAR_INSTRUCTIONS_PUBKEY, SystemProgram, PublicKey } from '@solana/web3.js';
import { ASSOCIATED_TOKEN_PROGRAM_ID, getAssociatedTokenAddressSync } from '@solana/spl-token';
import { l as liquidity } from '../shared/lend.CioR9-te.mjs';
import { Program } from '@coral-xyz/anchor';
import { b as lending, g as getLendingToken, c as getLending, d as getLendingRewardsRateModel, e as getClaimAccount, f as getLendingAdmin } from '../shared/lend.DS0KoPpL.mjs';
import { g as getLiquidity, a as getRateModel, b as getUserBorrowPosition, c as getUserSupplyPosition, d as getTokenReserveFromAsset, e as getReserve } from '../shared/lend.BzG5ldOV.mjs';
import BN from 'bn.js';

const getLendingProgram = ({
  connection,
  signer
}) => new Program(lending, {
  connection,
  publicKey: signer
});
const getAccountOwner = async (account, connection) => {
  const info = await connection.getAccountInfo(account);
  if (!info)
    throw new Error(`Account info not found for ${account.toString()}`);
  return info.owner;
};

const LIQUIDITY_PROGRAM_ID = new PublicKey(liquidity.address);
async function getDepositContext({
  asset,
  signer,
  connection
}) {
  const lendingToken = getLendingToken(asset);
  const lending$1 = getLending(asset);
  const liquidityKey = getLiquidity();
  const tokenProgram = await getAccountOwner(asset, connection);
  return {
    signer,
    depositorTokenAccount: getAssociatedTokenAddressSync(
      asset,
      signer,
      false,
      tokenProgram
    ),
    recipientTokenAccount: getAssociatedTokenAddressSync(
      lendingToken,
      signer,
      false,
      tokenProgram
    ),
    lendingAdmin: getLendingAdmin(),
    lending: lending$1,
    mint: asset,
    fTokenMint: lendingToken,
    claimAccount: getClaimAccount(
      asset,
      getLendingAdmin()
    ),
    supplyTokenReservesLiquidity: getTokenReserveFromAsset(asset),
    borrowTokenReservesLiquidity: getTokenReserveFromAsset(asset),
    lendingSupplyPositionOnLiquidity: getUserSupplyPosition(
      asset,
      lending$1
    ),
    lendingBorrowPositionOnLiquidity: getUserBorrowPosition(
      asset,
      lending$1
    ),
    rateModel: getRateModel(asset),
    vault: getAssociatedTokenAddressSync(
      asset,
      liquidityKey,
      true,
      tokenProgram
    ),
    liquidity: liquidityKey,
    liquidityProgram: LIQUIDITY_PROGRAM_ID,
    rewardsRateModel: getLendingRewardsRateModel(asset),
    tokenProgram,
    associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
    systemProgram: SystemProgram.programId,
    sysvarInstruction: SYSVAR_INSTRUCTIONS_PUBKEY
  };
}
const getDepositIx = async ({
  amount,
  asset,
  signer,
  connection
}) => {
  const program = getLendingProgram({
    connection,
    signer
  });
  return await program.methods.deposit(amount).accounts(
    await getDepositContext({
      asset,
      signer,
      connection
    })
  ).instruction();
};
const getMintIx = async ({
  shares,
  asset,
  signer,
  connection
}) => {
  const program = getLendingProgram({
    connection,
    signer
  });
  return await program.methods.mint(shares).accounts(
    await getDepositContext({
      asset,
      signer,
      connection
    })
  ).instruction();
};
async function getWithdrawContext({
  asset,
  signer,
  connection
}) {
  const lendingToken = getLendingToken(asset);
  const lending$1 = getLending(asset);
  const liquidityKey = getLiquidity();
  const tokenProgram = await getAccountOwner(asset, connection);
  return {
    signer,
    ownerTokenAccount: getAssociatedTokenAddressSync(
      lendingToken,
      signer,
      false,
      tokenProgram
    ),
    recipientTokenAccount: getAssociatedTokenAddressSync(
      asset,
      signer,
      false,
      tokenProgram
    ),
    lendingAdmin: getLendingAdmin(),
    lending: lending$1,
    mint: asset,
    claimAccount: getClaimAccount(
      asset,
      getLendingAdmin()
    ),
    fTokenMint: lendingToken,
    supplyTokenReservesLiquidity: getTokenReserveFromAsset(asset),
    lendingSupplyPositionOnLiquidity: getUserSupplyPosition(
      asset,
      lending$1
    ),
    rateModel: getRateModel(asset),
    vault: getAssociatedTokenAddressSync(
      asset,
      liquidityKey,
      true,
      tokenProgram
    ),
    liquidity: liquidityKey,
    liquidityProgram: LIQUIDITY_PROGRAM_ID,
    rewardsRateModel: getLendingRewardsRateModel(asset),
    tokenProgram,
    associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
    systemProgram: SystemProgram.programId,
    sysvarInstruction: SYSVAR_INSTRUCTIONS_PUBKEY
  };
}
const getWithdrawIx = async ({
  amount,
  asset,
  signer,
  connection
}) => {
  const program = getLendingProgram({
    connection,
    signer
  });
  return await program.methods.withdraw(amount).accounts(
    await getWithdrawContext({
      asset,
      signer,
      connection
    })
  ).instruction();
};
const getRedeemIx = async ({
  shares,
  asset,
  signer,
  connection
}) => {
  const program = getLendingProgram({
    connection,
    signer
  });
  return await program.methods.redeem(shares).accounts(
    await getWithdrawContext({
      asset,
      signer,
      connection
    })
  ).instruction();
};

const LENDING_CONSTANTS = {
  EXCHANGE_PRICES_PRECISION: new BN(1e12),
  // 1e12
  SECONDS_PER_YEAR: new BN(31536e3),
  MAX_REWARDS_RATE: new BN(50 * 1e12)
  // 50%
};
async function getLendingData(address, program) {
  const [lendingRes] = await program.account.lending.all([
    {
      memcmp: {
        bytes: address.toBase58(),
        offset: 8 + 32
        // f_token_mint
      }
    }
  ]);
  if (!lendingRes) {
    throw new Error(`Lending Token ${address} is not found`);
  }
  return lendingRes.account;
}
function calculateTotalAssets(lending, totalSupply) {
  const tokenExchangePrice = new BN(lending.tokenExchangePrice.toString());
  const totalSupplyBN = typeof totalSupply === "number" || typeof totalSupply === "string" ? new BN(String(totalSupply)) : totalSupply;
  return Number.parseInt(
    tokenExchangePrice.mul(totalSupplyBN).div(LENDING_CONSTANTS.EXCHANGE_PRICES_PRECISION).toString()
  );
}
const getTokenTotalSupply = async (asset, conn) => {
  if (asset.equals(PublicKey.default) || asset.toString() === "So11111111111111111111111111111111111111112") {
    console.warn("Token supply for SOL is not available");
    return "0";
  }
  const { value } = await conn.getTokenSupply(asset);
  return value.amount;
};
const getTokenBalance = async (owner, mintAddress, conn) => {
  try {
    if (mintAddress.equals(PublicKey.default) || mintAddress.toBase58() === "So11111111111111111111111111111111111111111") {
      const balance = await conn.getBalance(owner);
      return balance;
    }
    const tokenAccount = getAssociatedTokenAddressSync(
      mintAddress,
      owner,
      true,
      await getAccountOwner(mintAddress, conn)
    );
    const tokenAmount = await conn.getTokenAccountBalance(tokenAccount);
    return Number(tokenAmount.value.amount);
  } catch {
    return 0;
  }
};
async function getRewardsRate(asset, totalAssets, connection) {
  const program = getLendingProgram({ connection });
  const currentRateModel = await program.account.lendingRewardsRateModel.fetch(
    getLendingRewardsRateModel(asset)
  );
  if (totalAssets.lt(currentRateModel.startTvl)) {
    return {
      rate: new BN(0),
      rewardsEnded: false,
      rewardsStartTime: currentRateModel.startTime
    };
  }
  const rate = currentRateModel.yearlyReward.mul(LENDING_CONSTANTS.EXCHANGE_PRICES_PRECISION).div(totalAssets);
  if (rate.gt(LENDING_CONSTANTS.MAX_REWARDS_RATE)) {
    return {
      rate: LENDING_CONSTANTS.MAX_REWARDS_RATE,
      rewardsEnded: false,
      rewardsStartTime: currentRateModel.startTime
    };
  }
  return {
    rate,
    rewardsEnded: false,
    rewardsStartTime: currentRateModel.startTime
  };
}
async function getLiquidityExchangePricesAndConfig(assetAddress, connection) {
  const program = getLendingProgram({ connection });
  const account = await program.account.tokenReserve.fetch(
    getReserve(assetAddress)
  );
  const tokenReserve = {
    mint: account.mint,
    supplyExchangePrice: account.supplyExchangePrice,
    borrowExchangePrice: account.borrowExchangePrice,
    borrowRate: new BN(account.borrowRate || 0),
    fee: new BN(account.feeOnInterest || 0),
    lastStoredUtilization: new BN(account.lastUtilization || 0),
    lastUpdateTimestamp: account.lastUpdateTimestamp,
    maxUtilization: new BN(account.maxUtilization || 9500),
    supplyInterest: account.totalSupplyWithInterest,
    supplyInterestFree: account.totalSupplyInterestFree,
    borrowInterest: account.totalBorrowWithInterest,
    borrowInterestFree: account.totalBorrowInterestFree
  };
  return {
    supplyExchangePrice: tokenReserve.supplyExchangePrice,
    borrowExchangePrice: tokenReserve.borrowExchangePrice,
    borrowRate: tokenReserve.borrowRate,
    fee: tokenReserve.fee,
    lastStoredUtilization: tokenReserve.lastStoredUtilization,
    lastUpdateTimestamp: tokenReserve.lastUpdateTimestamp,
    maxUtilization: tokenReserve.maxUtilization || new BN(9500)
  };
}
async function getNewExchangePrice(lending, connection) {
  const { supplyExchangePrice: liquidityExchangePrice } = await getLiquidityExchangePricesAndConfig(lending.mint, connection);
  const oldTokenExchangePrice = new BN(lending.tokenExchangePrice.toString());
  const oldLiquidityExchangePrice = new BN(
    lending.liquidityExchangePrice.toString()
  );
  let totalReturnPercent = new BN(0);
  const totalSupply = await getTokenTotalSupply(lending.fTokenMint, connection);
  const totalAssets = oldTokenExchangePrice.mul(new BN(totalSupply)).div(LENDING_CONSTANTS.EXCHANGE_PRICES_PRECISION);
  let rewardsRate = await getRewardsRate(lending.mint, totalAssets, connection);
  if (rewardsRate.rate.gt(LENDING_CONSTANTS.MAX_REWARDS_RATE)) {
    rewardsRate.rate = new BN(0);
  }
  let lastUpdateTime = new BN(lending.lastUpdateTimestamp.toString());
  if (lastUpdateTime < rewardsRate.rewardsStartTime) {
    lastUpdateTime = rewardsRate.rewardsStartTime;
  }
  totalReturnPercent = rewardsRate.rate.mul(new BN(Math.floor(Date.now() / 1e3)).sub(lastUpdateTime)).div(LENDING_CONSTANTS.SECONDS_PER_YEAR);
  const delta = new BN(liquidityExchangePrice).sub(oldLiquidityExchangePrice);
  totalReturnPercent = totalReturnPercent.add(
    delta.mul(new BN(1e14)).div(oldLiquidityExchangePrice)
  );
  return oldTokenExchangePrice.add(
    oldTokenExchangePrice.mul(totalReturnPercent).div(new BN(1e14))
  );
}
async function calculateRewardsRate(currentModel, totalAssets) {
  const currentTimestamp = new BN(Math.floor(Date.now() / 1e3));
  const defaultResult = {
    rewardsRate: new BN(0),
    rewardsEnded: false,
    rewardsStartTime: new BN(currentModel.startTime.toString())
  };
  if (currentModel.startTime.isZero() || currentModel.duration.isZero()) {
    return defaultResult;
  }
  if (currentTimestamp > currentModel.startTime.add(currentModel.duration)) {
    return {
      ...defaultResult,
      rewardsEnded: true
    };
  }
  if (new BN(totalAssets).lt(currentModel.startTvl)) {
    return defaultResult;
  }
  let rewardsRate = new BN(currentModel.yearlyReward.toString()).mul(new BN(1e4)).div(new BN(totalAssets.toString()));
  if (rewardsRate.gt(LENDING_CONSTANTS.MAX_REWARDS_RATE)) {
    rewardsRate = LENDING_CONSTANTS.MAX_REWARDS_RATE;
  }
  return {
    rewardsRate,
    rewardsEnded: false,
    rewardsStartTime: new BN(currentModel.startTime.toString())
  };
}
async function getLendingTokenRewards(lending, connection) {
  let rewardsRate = new BN(0);
  if (!lending.rewardsRateModel.equals(PublicKey.default)) {
    try {
      const fTokenSupply = await getTokenTotalSupply(
        lending.fTokenMint,
        connection
      );
      const totalAssets = calculateTotalAssets(lending, fTokenSupply);
      const currentRateModel = await fetchRewardsRateModel(
        lending.rewardsRateModel,
        connection
      );
      const result = await calculateRewardsRate(currentRateModel, totalAssets);
      rewardsRate = result.rewardsRate;
    } catch (error_) {
      console.error(
        `Error calculating rewards rate for ${lending.mint}:`,
        error_
      );
    }
  }
  return {
    rewardRateModel: lending.rewardsRateModel,
    rewardsRate
  };
}
async function fetchRewardsRateModel(address, connection) {
  try {
    const program = getLendingProgram({ connection });
    const fetchedAccount = await connection.getAccountInfo(address);
    if (!fetchedAccount) {
      throw new Error(
        `Rewards rate model account not found: ${address.toString()}`
      );
    }
    return await program.account.lendingRewardsRateModel.fetch(address);
  } catch (error_) {
    console.error(
      `Error fetching rewards rate model ${address.toString()}:`,
      error_
    );
    throw error_;
  }
}
async function convertToAssets(asset, shares, connection) {
  const program = getLendingProgram({ connection });
  const lending$1 = await program.account.lending.fetch(
    getLending(asset)
  );
  const exchangePrice = await getNewExchangePrice(lending$1, connection);
  return shares.mul(exchangePrice).divRound(LENDING_CONSTANTS.EXCHANGE_PRICES_PRECISION);
}
async function getTokenReserveAccount(asset, connection) {
  const program = getLendingProgram({ connection });
  const tokenReservePDA = getReserve(asset);
  try {
    const account = await program.account.tokenReserve.fetch(tokenReservePDA);
    return {
      mint: account.mint,
      supplyExchangePrice: account.supplyExchangePrice,
      borrowExchangePrice: account.borrowExchangePrice,
      borrowRate: new BN(account.borrowRate || 0),
      fee: new BN(account.feeOnInterest || 0),
      lastStoredUtilization: new BN(account.lastUtilization || 0),
      lastUpdateTimestamp: account.lastUpdateTimestamp,
      maxUtilization: new BN(account.maxUtilization || 9500),
      supplyInterest: account.totalSupplyWithInterest,
      supplyInterestFree: account.totalSupplyInterestFree,
      borrowInterest: account.totalBorrowWithInterest,
      borrowInterestFree: account.totalBorrowInterestFree
    };
  } catch {
    throw new Error(
      `Token reserve account not found for asset ${asset.toString()}`
    );
  }
}
async function getTotalAmounts(asset, connection) {
  const tokenReserve = await getTokenReserveAccount(asset, connection);
  if (!tokenReserve) return;
  return {
    supplyRawInterest: tokenReserve.supplyInterest,
    supplyInterestFree: tokenReserve.supplyInterestFree,
    borrowRawInterest: tokenReserve.borrowInterest,
    borrowInterestFree: tokenReserve.borrowInterestFree
  };
}
async function getLiquidityAssetSupplyRate(asset, connection) {
  const [exchangePricesAndConfig, totalAmounts] = await Promise.all([
    getLiquidityExchangePricesAndConfig(asset, connection),
    getTotalAmounts(asset, connection)
  ]);
  let supplyRate = new BN(0);
  if (!totalAmounts) {
    return supplyRate;
  }
  let borrowRate = exchangePricesAndConfig.borrowRate;
  let fee = exchangePricesAndConfig.fee;
  if (!totalAmounts.supplyRawInterest.isZero()) {
    const borrowWithInterestForRate = totalAmounts.borrowRawInterest.mul(exchangePricesAndConfig.borrowExchangePrice).div(LENDING_CONSTANTS.EXCHANGE_PRICES_PRECISION);
    const supplyWithInterestForRate = totalAmounts.supplyRawInterest.mul(exchangePricesAndConfig.supplyExchangePrice).div(LENDING_CONSTANTS.EXCHANGE_PRICES_PRECISION);
    if (!supplyWithInterestForRate.isZero()) {
      supplyRate = borrowRate.mul(new BN(1e4).sub(fee)).mul(borrowWithInterestForRate).div(supplyWithInterestForRate.mul(new BN(1e4)));
    }
  }
  return supplyRate;
}
const getLendingTokens = async ({
  connection
}) => {
  const program = getLendingProgram({ connection });
  const lending = await program.account.lending.all();
  const data = lending.map((l) => l.account);
  data.sort((a, b) => a.lendingId - b.lendingId);
  return lending.map((l) => l.account.fTokenMint);
};
const getLendingTokenDetails = async ({
  lendingToken,
  connection
}) => {
  const program = getLendingProgram({ connection });
  const lendingData = await getLendingData(lendingToken, program);
  const [assetTotalSupply, supplyRate, exchangePrice, { rewardsRate }] = await Promise.all([
    getTokenTotalSupply(lendingData.fTokenMint, connection),
    getLiquidityAssetSupplyRate(lendingData.mint, connection),
    getNewExchangePrice(lendingData, connection),
    getLendingTokenRewards(lendingData, connection)
  ]);
  const convertToShares = new BN(10).pow(new BN(lendingData.decimals)).mul(LENDING_CONSTANTS.EXCHANGE_PRICES_PRECISION).divRound(exchangePrice);
  const convertToAssets2 = new BN(10).pow(new BN(lendingData.decimals)).mul(exchangePrice).divRound(LENDING_CONSTANTS.EXCHANGE_PRICES_PRECISION);
  const totalAssets = calculateTotalAssets(lendingData, assetTotalSupply);
  return {
    id: lendingData.lendingId,
    address: lendingData.fTokenMint,
    asset: lendingData.mint,
    decimals: lendingData.decimals,
    totalAssets: new BN(totalAssets.toString()),
    totalSupply: new BN(assetTotalSupply),
    convertToShares,
    convertToAssets: convertToAssets2,
    rewardsRate,
    supplyRate
  };
};
const getUserLendingPositionByAsset = async ({
  user,
  asset,
  connection
}) => {
  const lendingTokenBalance = await getTokenBalance(
    user,
    getLendingToken(asset),
    connection
  );
  const underlyingBalance = await getTokenBalance(user, asset, connection);
  const assets = await convertToAssets(
    asset,
    new BN(lendingTokenBalance.toString()),
    connection
  );
  return {
    lendingTokenShares: new BN(lendingTokenBalance.toString()),
    underlyingAssets: assets,
    underlyingBalance: new BN(underlyingBalance.toString())
  };
};

export { getAccountOwner, getDepositContext, getDepositIx, getLendingProgram, getLendingTokenDetails, getLendingTokens, getMintIx, getRedeemIx, getUserLendingPositionByAsset, getWithdrawContext, getWithdrawIx };
